/** 
 * Creates (but doesn't start) the animations for the next transition based on the current and next layout states. <p>After this is called, MountState can use  {@link #isAnimating} and {@link #isDisappearing} tocheck whether certain mount content will animate, commit the layout changes, and then call {@link #runTransitions} to restore the initial states and run the animations.
 */
void setupTransitions(LayoutState currentLayoutState,LayoutState nextLayoutState,Transition rootTransition){
  final boolean isTracing=ComponentsSystrace.isTracing();
  if (isTracing) {
    ComponentsSystrace.beginSection("TransitionManager.setupTransition");
  }
  for (  AnimationState animationState : mAnimationStates.values()) {
    animationState.seenInLastTransition=false;
  }
  final Map<TransitionId,OutputUnitsAffinityGroup<LayoutOutput>> nextTransitionIds=nextLayoutState.getTransitionIdMapping();
  if (currentLayoutState == null) {
    for (    TransitionId transitionId : nextTransitionIds.keySet()) {
      if (onlyProcessAutogeneratedTransitionIdsWhenNecessary && transitionId.mType == TransitionId.Type.AUTOGENERATED) {
        continue;
      }
      final OutputUnitsAffinityGroup<LayoutOutput> nextLayoutOutputsGroup=nextTransitionIds.get(transitionId);
      recordLayoutOutputsGroupDiff(transitionId,null,nextLayoutOutputsGroup);
    }
  }
 else {
    final Map<TransitionId,OutputUnitsAffinityGroup<LayoutOutput>> currentTransitionIds=currentLayoutState.getTransitionIdMapping();
    final HashSet<TransitionId> seenInNewLayout=new HashSet<>();
    final boolean doNotProcessAutogeneratedIds=onlyProcessAutogeneratedTransitionIdsWhenNecessary && !TransitionUtils.targetsAllLayout(rootTransition);
    for (    TransitionId transitionId : nextTransitionIds.keySet()) {
      final boolean isAutogenerated=transitionId.mType == TransitionId.Type.AUTOGENERATED;
      if (doNotProcessAutogeneratedIds && isAutogenerated) {
        continue;
      }
      final OutputUnitsAffinityGroup<LayoutOutput> nextLayoutOutputsGroup=nextTransitionIds.get(transitionId);
      final OutputUnitsAffinityGroup<LayoutOutput> currentLayoutOutputsGroup=currentTransitionIds.get(transitionId);
      if (currentLayoutOutputsGroup != null) {
        seenInNewLayout.add(transitionId);
      }
 else       if (isAutogenerated) {
        continue;
      }
      recordLayoutOutputsGroupDiff(transitionId,currentLayoutOutputsGroup,nextLayoutOutputsGroup);
    }
    for (    TransitionId transitionId : currentTransitionIds.keySet()) {
      if (seenInNewLayout.contains(transitionId) || (onlyProcessAutogeneratedTransitionIdsWhenNecessary && transitionId.mType == TransitionId.Type.AUTOGENERATED)) {
        continue;
      }
      recordLayoutOutputsGroupDiff(transitionId,currentTransitionIds.get(transitionId),null);
    }
  }
  createTransitionAnimations(rootTransition);
  cleanupNonAnimatingAnimationStates();
  if (isTracing) {
    ComponentsSystrace.endSection();
  }
}
