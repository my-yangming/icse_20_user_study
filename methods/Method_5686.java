/** 
 * Called from  {@link #selectTracks(MappedTrackInfo,int[][][],int[])} to make a track selectionfor each renderer, prior to overrides and disabled flags being applied. <p>The implementation should not account for overrides and disabled flags. Track selections generated by this method will be overridden to account for these properties.
 * @param mappedTrackInfo Mapped track information.
 * @param rendererFormatSupports The result of {@link RendererCapabilities#supportsFormat} foreach mapped track, indexed by renderer, track group and track (in that order).
 * @param rendererMixedMimeTypeAdaptationSupports The result of {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
 * @return The {@link TrackSelection.Definition}s for the renderers. A null entry indicates no selection was made.
 * @throws ExoPlaybackException If an error occurs while selecting the tracks.
 */
protected TrackSelection.@NullableType Definition[] selectAllTracks(MappedTrackInfo mappedTrackInfo,int[][][] rendererFormatSupports,int[] rendererMixedMimeTypeAdaptationSupports,Parameters params) throws ExoPlaybackException {
  int rendererCount=mappedTrackInfo.getRendererCount();
  TrackSelection.@NullableType Definition[] definitions=new TrackSelection.Definition[rendererCount];
  boolean seenVideoRendererWithMappedTracks=false;
  boolean selectedVideoTracks=false;
  for (int i=0; i < rendererCount; i++) {
    if (C.TRACK_TYPE_VIDEO == mappedTrackInfo.getRendererType(i)) {
      if (!selectedVideoTracks) {
        definitions[i]=selectVideoTrack(mappedTrackInfo.getTrackGroups(i),rendererFormatSupports[i],rendererMixedMimeTypeAdaptationSupports[i],params,true);
        selectedVideoTracks=definitions[i] != null;
      }
      seenVideoRendererWithMappedTracks|=mappedTrackInfo.getTrackGroups(i).length > 0;
    }
  }
  AudioTrackScore selectedAudioTrackScore=null;
  int selectedAudioRendererIndex=C.INDEX_UNSET;
  int selectedTextTrackScore=Integer.MIN_VALUE;
  int selectedTextRendererIndex=C.INDEX_UNSET;
  for (int i=0; i < rendererCount; i++) {
    int trackType=mappedTrackInfo.getRendererType(i);
switch (trackType) {
case C.TRACK_TYPE_VIDEO:
      break;
case C.TRACK_TYPE_AUDIO:
    Pair<TrackSelection.Definition,AudioTrackScore> audioSelection=selectAudioTrack(mappedTrackInfo.getTrackGroups(i),rendererFormatSupports[i],rendererMixedMimeTypeAdaptationSupports[i],params,!seenVideoRendererWithMappedTracks);
  if (audioSelection != null && (selectedAudioTrackScore == null || audioSelection.second.compareTo(selectedAudioTrackScore) > 0)) {
    if (selectedAudioRendererIndex != C.INDEX_UNSET) {
      definitions[selectedAudioRendererIndex]=null;
    }
    definitions[i]=audioSelection.first;
    selectedAudioTrackScore=audioSelection.second;
    selectedAudioRendererIndex=i;
  }
break;
case C.TRACK_TYPE_TEXT:
Pair<TrackSelection.Definition,Integer> textSelection=selectTextTrack(mappedTrackInfo.getTrackGroups(i),rendererFormatSupports[i],params);
if (textSelection != null && textSelection.second > selectedTextTrackScore) {
if (selectedTextRendererIndex != C.INDEX_UNSET) {
definitions[selectedTextRendererIndex]=null;
}
definitions[i]=textSelection.first;
selectedTextTrackScore=textSelection.second;
selectedTextRendererIndex=i;
}
break;
default :
definitions[i]=selectOtherTrack(trackType,mappedTrackInfo.getTrackGroups(i),rendererFormatSupports[i],params);
break;
}
}
return definitions;
}
