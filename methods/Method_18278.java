/** 
 * Traverses the layoutTree and the diffTree recursively. If a layoutNode has a compatible host type  {@link LayoutState#hostIsCompatible} it assigns the DiffNode to the layout node in orderto try to re-use the LayoutOutputs that will be generated by  {@link LayoutState#collectResults(ComponentContext,InternalNode,LayoutState,DiffNode)}. If a layoutNode component returns false when shouldComponentUpdate is called with the DiffNode Component it also tries to re-use the old measurements and therefore marks as valid the cachedMeasures for the whole component subtree.
 * @param layoutNode the root of the LayoutTree
 * @param diffNode the root of the diffTree
 * @return true if the layout node requires updating, false if it can re-use the measurements fromthe diff node.
 */
static void applyDiffNodeToUnchangedNodes(InternalNode layoutNode,DiffNode diffNode){
  try {
    final boolean isTreeRoot=layoutNode.getParent() == null;
    if (isLayoutSpecWithSizeSpec(layoutNode.getTailComponent()) && !isTreeRoot) {
      layoutNode.setDiffNode(diffNode);
      return;
    }
    if (!hostIsCompatible(layoutNode,diffNode)) {
      return;
    }
    layoutNode.setDiffNode(diffNode);
    final int layoutCount=layoutNode.getChildCount();
    final int diffCount=diffNode.getChildCount();
    if (layoutCount != 0 && diffCount != 0) {
      for (int i=0; i < layoutCount && i < diffCount; i++) {
        applyDiffNodeToUnchangedNodes(layoutNode.getChildAt(i),diffNode.getChildAt(i));
      }
    }
 else     if (!shouldComponentUpdate(layoutNode,diffNode)) {
      applyDiffNodeToLayoutNode(layoutNode,diffNode);
    }
  }
 catch (  Throwable t) {
    final Component c=layoutNode.getTailComponent();
    if (c != null) {
      throw new ComponentsChainException(c,t);
    }
    throw t;
  }
}
