/** 
 * Because this processor needs output of the @ContributesAndroidInjector, if it cannot find the subcomponents generated by that processor, it will just skip. But before that it needs to collect all the (sub)components and their builders.  {@link RoundEnvironment#getElementsAnnotatedWith(TypeElement)} can only get the element in its round.<p>TODO: currently, the will be executed for each library that contributes into the app. That fine because all the Subcompoments is depended by their parent (sub)component therefore we will get the full graph when building the lib with the parent component. In case of component, the process is reversed. They depends on their parent if any. There could be multiple libs with child components that depend on a parent component in another lib. In such case, no build target will have a full graph. And the parent component will be generated many times. But that's fine because all of them are identical. Doesn't matter which one is instantiated. And java can have multiple definition of same class in its class path.
 */
@Override protected boolean handle(Set<? extends TypeElement> annotations){
  logger.n("process()");
  if (done) {
    return true;
  }
  Set<TypeElement> newModules=utils.getTypedElements(roundEnvironment,Module.class);
  allModules.addAll(newModules);
  Set<Element> newInjected=utils.getTypedElements(roundEnvironment,Inject.class);
  allInjected.addAll(newInjected);
  if (isFirstRound || !newModules.isEmpty() || !newInjected.isEmpty()) {
    isFirstRound=false;
    return false;
  }
  Set<TypeElement> classesWithInject=Sets.newHashSet(Collections2.transform(allInjected,e -> {
    return (TypeElement)e.getEnclosingElement();
  }
));
  new ProxyGenerator(processingEnv,utils).generate(allModules,classesWithInject);
  done=true;
  return true;
}
