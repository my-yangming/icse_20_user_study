/** 
 * Exports the given scene to a chosen file format. Returns the exported data as a binary blob which you can write into a file or something. When you're done with the data, use  {@link #aiReleaseExportBlob ReleaseExportBlob} to free the resources associated with the export.
 * @param pScene         The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importeroutput format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions, have a look at the last parameter.
 * @param pFormatId      ID string to specify to which format you want to export to. Use {@link #aiGetExportFormatCount GetExportFormatCount} / {@link #aiGetExportFormatDescription GetExportFormatDescription} to learn which exportformats are available.
 * @param pPreProcessing Accepts any choice of the {@code aiPostProcessSteps} enumerated flags, but in reality only a subset of them makes sense here. Specifying'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. The  {@link #aiProcess_MakeLeftHanded Process_MakeLeftHanded},  {@link #aiProcess_FlipUVs Process_FlipUVs} and {@link #aiProcess_FlipWindingOrder Process_FlipWindingOrder} flags are used in the importside to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite effect, respectively. Some other of the  {@code aiPostProcessSteps} enumerated values may be useful as well, but you'll need to try out what theireffect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can enforce it by specifying the  {@link #aiProcess_Triangulate Process_Triangulate} flag, most export formats support only triangulate data so they would run the step anyway.<p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using  {@link #aiCopyScene CopyScene} and potentiallymodified afterwards), any postprocessing steps already applied to the scene will not be applied again, unless they show non-idempotent behaviour ( {@link #aiProcess_MakeLeftHanded Process_MakeLeftHanded},  {@link #aiProcess_FlipUVs Process_FlipUVs} and {@link #aiProcess_FlipWindingOrder Process_FlipWindingOrder}). One or more of:<br></p><table><tr><td> {@link #aiProcess_CalcTangentSpace Process_CalcTangentSpace}</td><td> {@link #aiProcess_JoinIdenticalVertices Process_JoinIdenticalVertices}</td><td> {@link #aiProcess_MakeLeftHanded Process_MakeLeftHanded}</td></tr><tr><td> {@link #aiProcess_Triangulate Process_Triangulate}</td><td> {@link #aiProcess_RemoveComponent Process_RemoveComponent}</td><td> {@link #aiProcess_GenNormals Process_GenNormals}</td></tr><tr><td> {@link #aiProcess_GenSmoothNormals Process_GenSmoothNormals}</td><td> {@link #aiProcess_SplitLargeMeshes Process_SplitLargeMeshes}</td><td> {@link #aiProcess_PreTransformVertices Process_PreTransformVertices}</td></tr><tr><td> {@link #aiProcess_LimitBoneWeights Process_LimitBoneWeights}</td><td> {@link #aiProcess_ValidateDataStructure Process_ValidateDataStructure}</td><td> {@link #aiProcess_ImproveCacheLocality Process_ImproveCacheLocality}</td></tr><tr><td> {@link #aiProcess_RemoveRedundantMaterials Process_RemoveRedundantMaterials}</td><td> {@link #aiProcess_FixInfacingNormals Process_FixInfacingNormals}</td><td> {@link #aiProcess_SortByPType Process_SortByPType}</td></tr><tr><td> {@link #aiProcess_FindDegenerates Process_FindDegenerates}</td><td> {@link #aiProcess_FindInvalidData Process_FindInvalidData}</td><td> {@link #aiProcess_GenUVCoords Process_GenUVCoords}</td></tr><tr><td> {@link #aiProcess_TransformUVCoords Process_TransformUVCoords}</td><td> {@link #aiProcess_FindInstances Process_FindInstances}</td><td> {@link #aiProcess_OptimizeMeshes Process_OptimizeMeshes}</td></tr><tr><td> {@link #aiProcess_OptimizeGraph Process_OptimizeGraph}</td><td> {@link #aiProcess_FlipUVs Process_FlipUVs}</td><td> {@link #aiProcess_FlipWindingOrder Process_FlipWindingOrder}</td></tr><tr><td> {@link #aiProcess_SplitByBoneCount Process_SplitByBoneCount}</td><td> {@link #aiProcess_Debone Process_Debone}</td><td> {@link #aiProcess_GlobalScale Process_GlobalScale}</td></tr><tr><td> {@link #aiProcess_EmbedTextures Process_EmbedTextures}</td><td> {@link #aiProcess_ForceGenNormals Process_ForceGenNormals}</td><td> {@link #aiProcess_DropNormals Process_DropNormals}</td></tr><tr><td> {@link #aiProcess_ConvertToLeftHanded Process_ConvertToLeftHanded}</td><td> {@link #aiProcessPreset_TargetRealtime_Fast ProcessPreset_TargetRealtime_Fast}</td><td> {@link #aiProcessPreset_TargetRealtime_Quality ProcessPreset_TargetRealtime_Quality}</td></tr><tr><td> {@link #aiProcessPreset_TargetRealtime_MaxQuality ProcessPreset_TargetRealtime_MaxQuality}</td></tr></table>
 * @return the exported data or {@code NULL} in case of error
 */
@Nullable @NativeType("struct aiExportDataBlob *") public static AIExportDataBlob aiExportSceneToBlob(@NativeType("struct aiScene const *") AIScene pScene,@NativeType("char const *") CharSequence pFormatId,@NativeType("unsigned int") int pPreProcessing){
  MemoryStack stack=stackGet();
  int stackPointer=stack.getPointer();
  try {
    stack.nUTF8(pFormatId,true);
    long pFormatIdEncoded=stack.getPointerAddress();
    long __result=naiExportSceneToBlob(pScene.address(),pFormatIdEncoded,pPreProcessing);
    return AIExportDataBlob.createSafe(__result);
  }
  finally {
    stack.setPointer(stackPointer);
  }
}
