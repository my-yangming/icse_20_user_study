/** 
 * Servo will flatten metric names as: getServoTypeTag()_getServoInstanceTag()_monitorName An implementation note.  If there's a version mismatch between hystrix-core and hystrix-servo-metric-publisher, the code below may reference a HystrixEventType.ThreadPool that does not exist in hystrix-core.  If this happens, a j.l.NoSuchFieldError occurs.  Since this data is not being generated by hystrix-core, it's safe to count it as 0 and we should log an error to get users to update their dependency set.
 */
private List<Monitor<?>> getServoMonitors(){
  List<Monitor<?>> monitors=new ArrayList<Monitor<?>>();
  monitors.add(new InformationalMetric<String>(MonitorConfig.builder("name").build()){
    @Override public String getValue(){
      return key.name();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("currentTime").withTag(DataSourceLevel.DEBUG).build()){
    @Override public Number getValue(){
      return System.currentTimeMillis();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("threadActiveCount").build()){
    @Override public Number getValue(){
      return metrics.getCurrentActiveCount();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("completedTaskCount").build()){
    @Override public Number getValue(){
      return metrics.getCurrentCompletedTaskCount();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("largestPoolSize").build()){
    @Override public Number getValue(){
      return metrics.getCurrentLargestPoolSize();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("totalTaskCount").build()){
    @Override public Number getValue(){
      return metrics.getCurrentTaskCount();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("queueSize").build()){
    @Override public Number getValue(){
      return metrics.getCurrentQueueSize();
    }
  }
);
  monitors.add(new GaugeMetric(MonitorConfig.builder("rollingMaxActiveThreads").withTag(DataSourceLevel.DEBUG).build()){
    @Override public Number getValue(){
      return metrics.getRollingMaxActiveThreads();
    }
  }
);
  monitors.add(safelyGetCumulativeMonitor("countThreadsExecuted",new Func0<HystrixEventType.ThreadPool>(){
    @Override public HystrixEventType.ThreadPool call(){
      return HystrixEventType.ThreadPool.EXECUTED;
    }
  }
));
  monitors.add(safelyGetCumulativeMonitor("countThreadsRejected",new Func0<HystrixEventType.ThreadPool>(){
    @Override public HystrixEventType.ThreadPool call(){
      return HystrixEventType.ThreadPool.REJECTED;
    }
  }
));
  monitors.add(safelyGetRollingMonitor("rollingCountThreadsExecuted",new Func0<HystrixEventType.ThreadPool>(){
    @Override public HystrixEventType.ThreadPool call(){
      return HystrixEventType.ThreadPool.EXECUTED;
    }
  }
));
  monitors.add(safelyGetRollingMonitor("rollingCountCommandsRejected",new Func0<HystrixEventType.ThreadPool>(){
    @Override public HystrixEventType.ThreadPool call(){
      return HystrixEventType.ThreadPool.REJECTED;
    }
  }
));
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_corePoolSize").build()){
    @Override public Number getValue(){
      return properties.coreSize().get();
    }
  }
);
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_maximumSize").build()){
    @Override public Number getValue(){
      return properties.maximumSize().get();
    }
  }
);
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_actualMaximumSize").build()){
    @Override public Number getValue(){
      return properties.actualMaximumSize();
    }
  }
);
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_keepAliveTimeInMinutes").build()){
    @Override public Number getValue(){
      return properties.keepAliveTimeMinutes().get();
    }
  }
);
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_queueSizeRejectionThreshold").build()){
    @Override public Number getValue(){
      return properties.queueSizeRejectionThreshold().get();
    }
  }
);
  monitors.add(new InformationalMetric<Number>(MonitorConfig.builder("propertyValue_maxQueueSize").build()){
    @Override public Number getValue(){
      return properties.maxQueueSize().get();
    }
  }
);
  return monitors;
}
