package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.io.PrintStream;
import java.io.PipedInputStream;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PipedOutputStream;
import java.io.BufferedOutputStream;
import org.apache.log4j.Level;
import com.intellij.util.WaitFor;

/**
 * The buffer size value is chosen arbitrarily without any reasonable argumentation
 * Just that default 1024 in the pipe stream classes seems to be too small
 */
public class FakeProcess extends Process {
  private static final Logger LOG = LogManager.getLogger(FakeProcess.class);
  public static final int TERMINATION_CODE = 137;
  private static final int BUFFER_SIZE = 65535;

  private final PrintStream myOldOut;
  private final PrintStream myOldErr;
  private final PipedInputStream myInputOut = new PipedInputStream(BUFFER_SIZE);
  private final PipedInputStream myInputErr = new PipedInputStream(BUFFER_SIZE);
  private final InputStream myBufIn = new BufferedInputStream(myInputOut);
  private final InputStream myBufErr = new BufferedInputStream(myInputErr);
  private int myExitCode = -1;
  private boolean myDestroyed = false;

  public FakeProcess() {
    myOldOut = System.out;
    myOldErr = System.err;
  }

  public void init() throws IOException {
    System.setOut(createCompositeWrapper(myInputOut));
    System.setErr(createCompositeWrapper(myInputErr));
  }

  private PrintStream createCompositeWrapper(PipedInputStream pipeInput) throws IOException {
    OutputStream newOut = new PipedOutputStream(pipeInput);
    return new PrintStream(new BufferedOutputStream(newOut));
  }

  public void setExitCode(int code) {
    myExitCode = code;
  }

  @Override
  public void destroy() {
    if (myDestroyed) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Already destroyed");
      }
      return;
    }
    myDestroyed = true;
    closeOutAndErr();
  }

  private void closeOutAndErr() {
    PrintStream newOut = System.out;
    PrintStream newErr = System.err;
    System.setOut(myOldOut);
    System.setErr(myOldErr);
    newOut.close();
    newErr.close();
  }

  @Override
  public int exitValue() {
    return myExitCode;
  }

  @Override
  public InputStream getErrorStream() {
    return myBufErr;
  }

  @Override
  public InputStream getInputStream() {
    return myBufIn;
  }

  @Override
  public OutputStream getOutputStream() {
    throw new UnsupportedOperationException("No output stream here");
  }

  @Override
  public int waitFor() throws InterruptedException {
    new WaitFor() {
      protected boolean condition() {
        return myDestroyed;
      }
    };
    return myExitCode;
  }
}
