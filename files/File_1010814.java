package jetbrains.mps.editor.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import jetbrains.mps.nodeEditor.checking.DisposableEditorChecker;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Set;
import jetbrains.mps.checkers.AbstractNodeCheckerInEditor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.nodeEditor.checking.EditorChecker;
import jetbrains.mps.nodeEditor.checking.UpdateResult;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.util.Cancellable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typechecking.backend.TypecheckingSession;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.typechecking.TypecheckingFacade;
import java.util.function.Supplier;
import com.intellij.openapi.project.IndexNotReadyException;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.inspector.InspectorEditorComponent;
import jetbrains.mps.typesystem.LegacyTypecheckingQueries;
import jetbrains.mps.typesystem.LegacyTypecheckingProvider;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import org.apache.log4j.Level;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.checkers.LanguageErrorsComponent;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.errors.item.QuickFixBase;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.errors.item.NodeReportItem;
import jetbrains.mps.nodeEditor.HighlighterMessage;
import jetbrains.mps.errors.item.QuickFixReportItem;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.nodeEditor.checking.QuickFixRuntimeEditorWrapper;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.extapi.model.TransientSModel;
import jetbrains.mps.nodeEditor.EditorSettings;

public class LanguageEditorChecker extends BaseEditorChecker implements DisposableEditorChecker {
  private static final Logger LOG = LogManager.getLogger(LanguageEditorChecker.class);
  private boolean myMessagesChanged = false;
  private boolean myForceRunQuickFixes = false;
  private Set<AbstractNodeCheckerInEditor> myRules;

  private final ErrorComponents myErrorComponents;

  public LanguageEditorChecker(@NotNull SRepository projectRepo, Iterable<AbstractNodeCheckerInEditor> checkers) {
    myRules = SetSequence.fromSetWithValues(new LinkedHashSet<AbstractNodeCheckerInEditor>(), checkers);
    myErrorComponents = new ErrorComponents(projectRepo);
  }

  @Override
  public void dispose() {
    myErrorComponents.dispose();
  }

  @Override
  public boolean isLaterThan(EditorChecker checker) {
    // since this is default editor checker, 
    // every other checker knows whether it should be later or earlier than this one 
    if (checker instanceof LanguageEditorChecker) {
      return false;
    }
    if (checker.isLaterThan(this)) {
      return false;
    }
    return true;
  }

  @NotNull
  public UpdateResult update(final EditorComponent editorComponent, final boolean incremental, boolean applyQuickFixes, final Cancellable cancellable) {
    final SNode node = editorComponent.getEditedNode();
    try {
      TypecheckingSession typecheckingSession = editorComponent.getTypecheckingSession();
      if (typecheckingSession == null) {
        return UpdateResult.CANCELLED;
      }

      Set<EditorMessage> messages = TypecheckingFacade.getFromContext().runWithSession(typecheckingSession, new Supplier<Set<EditorMessage>>() {
        @Override
        public Set<EditorMessage> get() {
          return doCreateMessages(node, incremental, editorComponent.getEditorContext(), cancellable);
        }

      });
      return new UpdateResult.Completed(myMessagesChanged, messages);
    } catch (IndexNotReadyException e) {
      myErrorComponents.clear(editorComponent);
      throw e;
    }
  }

  private Set<EditorMessage> doCreateMessages(SNode node, boolean wasCheckedOnce, EditorContext editorContext, Cancellable cancellable) {
    EditorComponent editorComponent = (EditorComponent) editorContext.getEditorComponent();
    boolean inspector = editorComponent instanceof InspectorEditorComponent;

    // FIXME assuming it's safe to access legacy session 
    LegacyTypecheckingQueries ltq = editorComponent.getTypecheckingSession().getQueries(LegacyTypecheckingProvider.class);
    TypeCheckingContext typeCheckingContext = ltq.getTypeCheckingContext();

    myMessagesChanged = false;

    SNode editedNode = editorComponent.getEditedNode();

    if (editedNode == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("edited node is null");
      }
      return Collections.emptySet();
    }
    if (node.getModel() == null || SNodeOperations.getModel(editedNode) == null) {
      // descriptor is null for a replaced model 
      // after model is replaced but before it is disposed (this can happen asyncronously) 
      return Collections.emptySet();
    }

    LanguageErrorsComponent errorsComponent = myErrorComponents.getErrorsComponent(editorComponent);
    if (errorsComponent == null) {
      return Collections.emptySet();
    }

    if (!(wasCheckedOnce)) {
      errorsComponent.clear();
    }

    myMessagesChanged = runChecks(inspector, errorsComponent, typeCheckingContext, node, editorContext, cancellable);

    if (!(myMessagesChanged)) {
      // skipping further processing if nothing was changed 
      return Collections.emptySet();
    }

    return createMessages(editorContext, inspector, errorsComponent, editedNode);
  }

  private boolean runChecks(boolean inspector, LanguageErrorsComponent errorsComponent, TypeCheckingContext typeCheckingContext, SNode node, EditorContext editorContext, Cancellable cancellable) {
    if (inspector) {
      return errorsComponent.checkInspector();
    }

    try {
      if (typeCheckingContext != null) {
        typeCheckingContext.setIsNonTypesystemComputation();
      }
      return errorsComponent.check(SNodeOperations.getContainingRoot(((SNode) node)), myRules, editorContext.getRepository(), cancellable);
    } finally {
      if (typeCheckingContext != null) {
        typeCheckingContext.resetIsNonTypesystemComputation();
      }
    }
  }

  private Set<EditorMessage> createMessages(final EditorContext editorContext, boolean inspector, LanguageErrorsComponent errorsComponent, SNode editedNode) {
    Set<EditorMessage> result = SetSequence.fromSet(new HashSet<EditorMessage>());
    boolean runQuickFixes = shouldRunQuickFixs(editorContext.getModel(), inspector);
    final List<QuickFixBase> quickFixesToExecute = ListSequence.fromList(new ArrayList<QuickFixBase>());
    for (NodeReportItem errorReporter : errorsComponent.getErrors()) {
      // todo here should be processor-based architecture, like in other checkers 
      SNode nodeWithError = errorReporter.getNode().resolve(editorContext.getRepository());

      if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(nodeWithError, null, true)).contains(editedNode))) {
        // in inspector skipping all messages for invisible nodes 
        continue;
      }
      HighlighterMessage message = new HighlighterMessage(this, errorReporter, errorReporter.getNode().resolve(editorContext.getRepository()));
      if (runQuickFixes) {
        QuickFixBase quickFix = QuickFixReportItem.FLAVOUR_QUICKFIX.getAutoApplicable(message.getReportItem());
        if (quickFix != null) {
          ListSequence.fromList(quickFixesToExecute).addElement(quickFix);
        }
      }
      SetSequence.fromSet(result).addElement(message);
    }

    if (inspector) {
      return result;
    }
    // running quick fixes in main editor only 
    final boolean wasForceRunQuickFixes = myForceRunQuickFixes;
    myForceRunQuickFixes = false;
    if (ListSequence.fromList(quickFixesToExecute).isNotEmpty()) {
      ApplicationManager.getApplication().invokeLater(new Runnable() {
        public void run() {
          editorContext.getRepository().getModelAccess().executeUndoTransparentCommand(new Runnable() {
            public void run() {
              for (QuickFixBase fix : quickFixesToExecute) {
                if (fix.isAlive(editorContext.getRepository())) {
                  QuickFixRuntimeEditorWrapper.getInstance(fix).execute(editorContext, false);
                  if (wasForceRunQuickFixes) {
                    // forcing to execute quickFixes for all errors reported on the modified model 
                    myForceRunQuickFixes = true;
                  }
                }
              }
            }
          });
        }
      });
    }
    return result;
  }

  private boolean shouldRunQuickFixs(SModel model, boolean inspector) {
    if (inspector || !(model instanceof EditableSModel) || model instanceof TransientSModel) {
      return false;
    }
    return EditorSettings.getInstance().isAutoQuickFix() || myForceRunQuickFixes;
  }

  @Override
  public void forceAutofix(EditorComponent component) {
    myForceRunQuickFixes = true;
  }

  @Override
  public boolean needsUpdate(EditorComponent component) {
    return true;
  }
}
