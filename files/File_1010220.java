package jetbrains.mps.checkers;

/*Generated by MPS */

import jetbrains.mps.errors.item.IssueKindReportItem;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Collection;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.util.SubProgressKind;

public class IteratingChecker<O, P, I extends IssueKindReportItem> implements IAbstractChecker<O, I> {

  public interface IteratorWithProgress<T> extends Iterator<T> {
    /**
     * 
     * @return size of remaining part of iterating sequence measured in parrots (for list iterator it is size of remaining part of the list)
     */
    int remainingSize();
    /**
     * 
     * @return value on which remainingSize was decreased
     */
    Tuples._2<T, Integer> nextItem();
  }

  public static abstract class AbstractIteratorWithProgress<T> implements IteratingChecker.IteratorWithProgress<T> {
    private int myRemainingSize;
    public AbstractIteratorWithProgress(int initialSize) {
      myRemainingSize = initialSize;
    }
    @Override
    public final T next() {
      return nextItem()._0();
    }
    @Override
    public final Tuples._2<T, Integer> nextItem() {
      Tuples._2<T, Integer> next = nextItemInternal();
      myRemainingSize -= (int) next._1();
      return next;
    }
    public abstract Tuples._2<T, Integer> nextItemInternal();
    @Override
    public final int remainingSize() {
      return myRemainingSize;
    }
    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  public static class CollectionIteratorWithProgress<T> extends IteratingChecker.AbstractIteratorWithProgress<T> implements IteratingChecker.IteratorWithProgress<T> {
    private Iterator<T> myOrigin;
    public CollectionIteratorWithProgress(Collection<T> collection) {
      super(collection.size());
      myOrigin = collection.iterator();
    }
    @Override
    public boolean hasNext() {
      return myOrigin.hasNext();
    }
    @Override
    public Tuples._2<T, Integer> nextItemInternal() {
      T result = myOrigin.next();
      return MultiTuple.<T,Integer>from(result, 1);
    }
  }

  private IChecker<P, ? extends I> myOrigin;
  private _FunctionTypes._return_P1_E0<? extends IteratingChecker.IteratorWithProgress<P>, ? super O> myIterate;
  public IteratingChecker(IChecker<P, ? extends I> origin, _FunctionTypes._return_P1_E0<? extends IteratingChecker.IteratorWithProgress<P>, ? super O> iterate) {
    myOrigin = origin;
    myIterate = iterate;
  }
  @Override
  public void check(O toCheck, SRepository repository, Consumer<? super I> errorCollector, ProgressMonitor monitor) {
    IteratingChecker.IteratorWithProgress<P> iterator = myIterate.invoke(toCheck);
    monitor.start("", iterator.remainingSize());
    while (iterator.hasNext() && !(monitor.isCanceled())) {
      Tuples._2<P, Integer> next = iterator.nextItem();
      myOrigin.check(next._0(), repository, errorCollector, monitor.subTask((int) next._1(), SubProgressKind.IGNORED));
    }
    monitor.done();
  }
}
