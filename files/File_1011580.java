package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.openapi.util.Key;
import jetbrains.mps.project.Project;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.util.FileUtil;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.extapi.module.SRepositoryExt;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.jetbrains.mps.openapi.model.SNode;
import java.io.File;
import jetbrains.mps.build.behavior.BuildProject__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.ModelDependencyUpdate;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.ide.make.DefaultMakeMessageHandler;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.MakeServiceComponent;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import org.apache.log4j.Level;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.module.SModuleFacet;
import jetbrains.mps.vfs.impl.IoFileSystem;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.tempmodel.NaiveJavaModuleFacet;
import jetbrains.mps.vfs.IFile;
import java.util.Collections;

public class DeployScript {
  private static final Logger LOG = LogManager.getLogger(DeployScript.class);
  public static final Key<DeployScript> KEY = Key.create("Deploy.Script");

  private final DeployScript.TemporalModuleWithDescriptorFile myModule;
  private final Project myProject;
  private final Set<SModel> myModelsToMake = SetSequence.fromSet(new HashSet<SModel>());
  private final String myDeployScriptPath;
  private final String myArtifactsPath;

  public DeployScript(@NotNull Project project, List<SNodeReference> plugins) {
    myProject = project;
    myModule = new DeployScript.TemporalModuleWithDescriptorFile(FileUtil.createTmpDir().getAbsolutePath());
    SRepository projectRepo = project.getRepository();
    assert projectRepo instanceof SRepositoryExt;
    ((SRepositoryExt) projectRepo).registerModule(myModule, project);

    SModel model = TemporaryModels.getInstance().createReadOnly(TempModuleOptions.forExistingModule(myModule));
    SetSequence.fromSet(myModelsToMake).addElement(model);

    SNode deployScriptNode = DeployScriptCreator.createDeployScript(myProject, plugins, myModule.getBaseDirectory());
    model.addRootNode(deployScriptNode);
    myDeployScriptPath = new File(myModule.getBaseDirectory(), BuildProject__BehaviorDescriptor.getOutputFileName_id4gSHdTptyu0.invoke(deployScriptNode)).getAbsolutePath();
    myArtifactsPath = new File(new File(new File(myModule.getBaseDirectory(), "build"), "artifacts"), SPropertyOperations.getString(deployScriptNode, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"))).getAbsolutePath();

    new ModelDependencyUpdate(model).updateUsedLanguages().updateImportedModels(projectRepo).updateModuleDependencies(projectRepo);
  }

  @Nullable
  public String make() {
    MakeSession session = new MakeSession(myProject, new DefaultMakeMessageHandler(myProject), false);
    IMakeService makeService = myProject.getComponent(MakeServiceComponent.class).get();
    if (makeService.openNewSession(session)) {
      Future<IResult> future = makeService.make(session, new ModelsToResources(myModelsToMake).canGenerateCondition(new _FunctionTypes._return_P1_E0<Boolean, SModel>() {
        public Boolean invoke(SModel m) {
          return true;
        }
      }).resources());
      IResult result = null;
      try {
        result = future.get();
      } catch (CancellationException ignore) {
      } catch (InterruptedException ignore) {
      } catch (ExecutionException ignore) {
      }
      if (result == null || !(result.isSucessful())) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Can not generate deploy script");
        }
        return null;
      }
      return myDeployScriptPath;
    }
    return null;
  }

  public String getArtifactsPath() {
    return myArtifactsPath;
  }

  public String getDeployScriptLocation() {
    return myDeployScriptPath;
  }

  public void dispose() {
    myProject.getModelAccess().runWriteAction(new Runnable() {
      public void run() {
        SRepository projectRepo = myProject.getRepository();
        ((SRepositoryExt) projectRepo).unregisterModule(myModule, myProject);
        FileUtil.delete(myModule.getBaseDirectory());
      }
    });
  }

  private static class TemporalModuleWithDescriptorFile extends AbstractModule {
    private final SModuleFacet myJavaModuleFacet;

    private TemporalModuleWithDescriptorFile(@NotNull String baseDir) {
      super(IoFileSystem.INSTANCE.getFile(baseDir).findChild("module.msd"));
      setModuleReference(new ModuleReference("Temp module for assembling plugins", ModuleId.regular()));
      myJavaModuleFacet = new NaiveJavaModuleFacet(this, "MODULE_SOURCE_GEN", "MODULE_CLASSES_GEN");
    }

    public File getBaseDirectory() {
      IFile moduleSourceDir = getModuleSourceDir();
      return new File(moduleSourceDir.getPath());
    }

    @NotNull
    @Override
    public Iterable<SModuleFacet> getFacets() {
      return Collections.singleton(myJavaModuleFacet);
    }

    public boolean isPackaged() {
      // don't ask 
      return false;
    }
  }
}
