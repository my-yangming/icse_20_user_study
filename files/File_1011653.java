package jetbrains.mps.console.ideCommands.runtime.util;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.findusages.model.scopes.ProjectScope;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import javax.swing.SwingUtilities;
import jetbrains.mps.ide.make.actions.MakeActionImpl;
import jetbrains.mps.ide.make.actions.MakeActionParameters;
import java.util.function.Consumer;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.module.SModuleFacet;
import jetbrains.mps.project.facets.GenerationTargetFacet;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.project.facets.TestsFacet;
import java.util.Map;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.ActionManager;
import jetbrains.mps.lang.plugin.behavior.ActionDeclaration__BehaviorDescriptor;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.actionSystem.DataContext;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;

public class IdeCommandUtil {
  public static void make(final Project project, final Iterable<? extends SModel> models, final Iterable<? extends SModule> modules, final boolean wholeProject, final boolean dirtyOnly, final boolean depClosure) {
    final Wrappers._T<List<SModel>> modelsToGenerate = new Wrappers._T<List<SModel>>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        if (wholeProject) {
          modelsToGenerate.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), new ProjectScope(project).getModels());
        } else {
          modelsToGenerate.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), ListSequence.fromList(ListSequence.fromListWithValues(new ArrayList<SModel>(), models)).concat(Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
            public Iterable<SModel> translate(SModule it) {
              return it.getModels();
            }
          })));
        }
        if (depClosure) {
          Iterable<SModel> dependencies = modelsToGenerate.value;
          int oldSize;
          do {
            dependencies = Sequence.fromIterable(dependencies).translate(new ITranslator2<SModel, SModel>() {
              public Iterable<SModel> translate(SModel it) {
                return Sequence.fromIterable(((Iterable<SModelReference>) SModelOperations.getImportedModelUIDs(it))).select(new ISelector<SModelReference, SModel>() {
                  public SModel select(SModelReference it) {
                    return it.resolve(project.getRepository());
                  }
                });
              }
            }).where(new IWhereFilter<SModel>() {
              public boolean accept(SModel it) {
                return GenerationFacade.canGenerate(it);
              }
            }).distinct().subtract(ListSequence.fromList(modelsToGenerate.value)).toListSequence();
            oldSize = ListSequence.fromList(modelsToGenerate.value).count();
            ListSequence.fromList(modelsToGenerate.value).addSequence(Sequence.fromIterable(dependencies));
          } while (ListSequence.fromList(modelsToGenerate.value).count() > oldSize);
        }
        if (dirtyOnly) {
          final ModelGenerationStatusManager mgsm = project.getComponent(ModelGenerationStatusManager.class);
          modelsToGenerate.value = ListSequence.fromList(modelsToGenerate.value).where(new IWhereFilter<SModel>() {
            public boolean accept(SModel it) {
              return mgsm.generationRequired(it);
            }
          }).toListSequence();
        } else {
          modelsToGenerate.value = ListSequence.fromList(modelsToGenerate.value).toListSequence();
        }
      }
    });
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        new MakeActionImpl(new MakeActionParameters(project).models(modelsToGenerate.value).cleanMake(false)).executeAction();
      }
    });
  }

  public static void cleanCaches(final Project project, final Iterable<? extends SModel> models, final Iterable<? extends SModule> modules, final boolean wholeProject) {
    final Wrappers._T<List<SModel>> modelsToClean = new Wrappers._T<List<SModel>>();
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        if (wholeProject) {
          modelsToClean.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), new ProjectScope(project).getModels());
        } else {
          modelsToClean.value = ListSequence.fromListWithValues(new ArrayList<SModel>(), ListSequence.fromList(ListSequence.fromListWithValues(new ArrayList<SModel>(), models)).concat(Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
            public Iterable<SModel> translate(SModule it) {
              return it.getModels();
            }
          })));
        }
      }
    });
    project.getComponent(ModelGenerationStatusManager.class).discard(ListSequence.fromList(modelsToClean.value).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return GenerationFacade.canGenerate(it);
      }
    }));
  }

  public static void removeGenSources(final Project project, final Iterable<? extends SModel> models, Iterable<? extends SModule> modules, final boolean wholeProject) {
    final Wrappers._T<Iterable<? extends SModule>> _modules = new Wrappers._T<Iterable<? extends SModule>>(modules);
    project.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        if (wholeProject) {
          _modules.value = (Iterable<? extends SModule>) (Iterable<SModule>) project.getProjectModulesWithGenerators();
        }
        final Consumer<IFile> deleteIfFile = new Consumer<IFile>() {
          public void accept(IFile file) {
            if (!(file.isDirectory())) {
              file.delete();
            }
          }
        };
        Sequence.fromIterable(models).where(new IWhereFilter<SModel>() {
          public boolean accept(SModel it) {
            return !(it.getModule().isPackaged()) && GenerationFacade.canGenerate(it);
          }
        }).visitAll(new IVisitor<SModel>() {
          public void visit(SModel model) {
            for (SModuleFacet mf : model.getModule().getFacets()) {
              if (mf instanceof GenerationTargetFacet) {
                GenerationTargetFacet genFacet = ((GenerationTargetFacet) mf);

                genFacet.getOutputLocation(model).getChildren().forEach(deleteIfFile);
                genFacet.getOutputCacheLocation(model).getChildren().forEach(deleteIfFile);
              }
              if (mf instanceof JavaModuleFacet) {
                ((JavaModuleFacet) mf).getClassesLocation(model).getChildren().forEach(deleteIfFile);
              }
            }
          }
        });
      }
    });
    Sequence.fromIterable(_modules.value).visitAll(new IVisitor<SModule>() {
      public void visit(SModule module) {
        // would be nice to handle all GenerationTargetFacet here, but for transition, rely on only facets we are aware at the moment (and those with single-root output) 
        // FWIF, DeleteModuleHelper.deleteModuleFiles is pretty much about the same. 
        ArrayList<IFile> roots = new ArrayList<IFile>(5);
        JavaModuleFacet jmf = module.getFacet(JavaModuleFacet.class);
        if (jmf != null) {
          roots.add(jmf.getOutputRoot());
          roots.add(jmf.getOutputCacheRoot());
          roots.add(jmf.getClassesGen());
        }
        TestsFacet testsFacet = module.getFacet(TestsFacet.class);
        if (testsFacet != null) {
          roots.add(testsFacet.getTestsOutputPath());
          roots.add(testsFacet.getOutputCacheRoot());
        }
        for (IFile f : roots) {
          if (f != null) {
            f.delete();
          }
        }
      }
    });
  }

  public static Map<String, Object> prepareParameters(Iterable<Tuples._2<String, Object>> parameters) {
    Map<String, Object> result = MapSequence.fromMap(new HashMap<String, Object>());
    for (Tuples._2<String, Object> parameter : Sequence.fromIterable(parameters)) {
      MapSequence.fromMap(result).put(parameter._0(), parameter._1());
    }
    return result;
  }

  public static void callAction(final SNode actionDeclaration, final Map<String, Object> parameters) {
    AnAction action = ActionManager.getInstance().getAction(ActionDeclaration__BehaviorDescriptor.getActionId_id2JiSCAPXEb8.invoke(actionDeclaration));
    ActionUtils.updateAndPerformAction(action, ActionUtils.createEvent(ActionPlaces.UNKNOWN, new DataContext() {
      @Nullable
      public Object getData(@NonNls String key) {
        return MapSequence.fromMap(parameters).get(key);
      }
    }));
  }

}
