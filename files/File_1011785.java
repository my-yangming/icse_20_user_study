package jetbrains.mps.vcs.platform.mergedriver;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vcs.platform.util.PluginUtil;
import com.intellij.openapi.vcs.VcsRoot;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.vcs.ProjectLevelVcsManager;
import com.intellij.openapi.ui.Messages;
import jetbrains.mps.util.NameUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.util.Computable;
import jetbrains.mps.util.StringsIO;
import jetbrains.mps.vcs.core.mergedriver.FileType;
import java.io.IOException;
import com.intellij.openapi.vcs.AbstractVcs;

/*package*/ class GitRepositoriesInstaller extends AbstractInstaller {
  private static final String ATTRIBUTES_FILE = ".gitattributes";
  public GitRepositoriesInstaller(Project project) {
    super(project);
  }
  @NotNull
  @Override
  protected AbstractInstaller.State install(final boolean dryRun) {
    if (!(PluginUtil.isGitPluginEnabled())) {
      return AbstractInstaller.State.NOT_ENABLED;
    }
    Iterable<VcsRoot> gitRoots = getGitRoots();
    if (Sequence.fromIterable(gitRoots).isEmpty()) {
      return AbstractInstaller.State.INSTALLED;
    } else {
      List<AbstractInstaller.State> states = Sequence.fromIterable(gitRoots).select(new ISelector<VcsRoot, AbstractInstaller.State>() {
        public AbstractInstaller.State select(VcsRoot r) {
          return installForRootInWrite(r.getPath(), dryRun);
        }
      }).toListSequence();
      if (ListSequence.fromList(states).all(new IWhereFilter<AbstractInstaller.State>() {
        public boolean accept(AbstractInstaller.State s) {
          return s == AbstractInstaller.State.INSTALLED;
        }
      })) {
        return AbstractInstaller.State.INSTALLED;
      } else if (ListSequence.fromList(states).any(new IWhereFilter<AbstractInstaller.State>() {
        public boolean accept(AbstractInstaller.State s) {
          return s == AbstractInstaller.State.OUTDATED;
        }
      })) {
        if (dryRun) {
          return AbstractInstaller.State.OUTDATED;
        }
      } else {
        if (dryRun) {
          return AbstractInstaller.State.NOT_INSTALLED;
        }
      }
      return installForRoots(gitRoots);
    }
  }
  private int getRootsToInstall() {
    return Sequence.fromIterable(getGitRoots()).select(new ISelector<VcsRoot, AbstractInstaller.State>() {
      public AbstractInstaller.State select(VcsRoot r) {
        return installForRootInWrite(r.getPath(), true);
      }
    }).where(new IWhereFilter<AbstractInstaller.State>() {
      public boolean accept(AbstractInstaller.State st) {
        return st == AbstractInstaller.State.NOT_INSTALLED || st == AbstractInstaller.State.OUTDATED;
      }
    }).count();
  }
  private Iterable<VcsRoot> getGitRoots() {
    VcsRoot[] allRoots = myProject.getComponent(ProjectLevelVcsManager.class).getAllVcsRoots();
    return Sequence.fromIterable(Sequence.fromArray(allRoots)).where(new IWhereFilter<VcsRoot>() {
      public boolean accept(VcsRoot root) {
        return "Git".equals(check_mnsjzr_a0a0a0a0b0e(root.getVcs()));
      }
    });
  }
  private AbstractInstaller.State installForRoots(Iterable<VcsRoot> roots) {
    int updated = 0;
    int failed = 0;
    for (VcsRoot root : Sequence.fromIterable(roots)) {
      if (installForRootInWrite(root.getPath(), false) == AbstractInstaller.State.INSTALLED) {
        updated++;
      } else {
        failed++;
      }
    }
    if (updated != 0) {
      Messages.showInfoMessage(myProject, "Successfully updated attributes for " + NameUtil.formatNumericalString(updated, "Git root"), "Attributes");
    }
    if (failed == 0) {
      return AbstractInstaller.State.INSTALLED;
    } else {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
  }
  @Override
  public String getActionTitle() {
    return "Git file attributes for " + NameUtil.formatNumericalString(getRootsToInstall(), "repository") + "  (.gitattributes)";
  }
  @Override
  public String getAffectedVcsName() {
    return "Git";
  }
  @NotNull
  private static AbstractInstaller.State installForRootInWrite(final VirtualFile vcsRootPath, final boolean dryRun) {
    if (dryRun) {
      return installForRoot(vcsRootPath, dryRun);
    } else {
      return ApplicationManager.getApplication().runWriteAction(new Computable<AbstractInstaller.State>() {
        public AbstractInstaller.State compute() {
          return installForRoot(vcsRootPath, dryRun);
        }
      });
    }
  }
  @NotNull
  private static AbstractInstaller.State installForRoot(VirtualFile vcsRootPath, boolean dryRun) {
    VirtualFile attributesFile = vcsRootPath.findChild(ATTRIBUTES_FILE);
    if (attributesFile != null && attributesFile.isDirectory()) {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
    try {
      if (attributesFile == null || !(attributesFile.exists())) {
        if (dryRun) {
          return AbstractInstaller.State.NOT_INSTALLED;
        }
        attributesFile = vcsRootPath.createChildData(GitRepositoriesInstaller.class, ATTRIBUTES_FILE);
      }
      final List<String> lines = StringsIO.readLines(attributesFile.getInputStream());

      if (Sequence.fromIterable(Sequence.fromArray(FileType.BY_NAME)).all(new IWhereFilter<FileType>() {
        public boolean accept(final FileType fname) {
          return ListSequence.fromList(lines).any(new IWhereFilter<String>() {
            public boolean accept(String line) {
              return line.matches("\\s*" + fname.getSuffix().replace(".", "\\.") + "\\s.*merge=mps\\s*");
            }
          });
        }
      }) && Sequence.fromIterable(Sequence.fromArray(FileType.BY_EXT)).all(new IWhereFilter<FileType>() {
        public boolean accept(final FileType ext) {
          return ListSequence.fromList(lines).any(new IWhereFilter<String>() {
            public boolean accept(String line) {
              return line.matches("\\s*\\*\\." + ext.getSuffix() + "\\s.*merge=mps\\s*");
            }
          });
        }
      })) {
        return AbstractInstaller.State.INSTALLED;
      }

      for (FileType fname : FileType.BY_NAME) {
        boolean addNew = true;
        for (int i = 0; i < ListSequence.fromList(lines).count(); i++) {
          if (ListSequence.fromList(lines).getElement(i).matches("\\s*" + fname.getSuffix() + "\\s.*")) {
            if (ListSequence.fromList(lines).getElement(i).contains("merge=mps")) {
              if (dryRun) {
                return AbstractInstaller.State.OUTDATED;
              }
            } else {
              ListSequence.fromList(lines).setElement(i, ListSequence.fromList(lines).getElement(i) + " merge=mps");
            }
            addNew = false;
          }
        }
        if (addNew) {
          ListSequence.fromList(lines).addElement(fname.getSuffix() + " text merge=mps");
        }
      }
      for (FileType ext : FileType.BY_EXT) {
        boolean addNew = true;
        for (int i = 0; i < ListSequence.fromList(lines).count(); i++) {
          if (ListSequence.fromList(lines).getElement(i).matches("\\s*\\*\\." + ext.getSuffix() + "\\s.*")) {
            if (ListSequence.fromList(lines).getElement(i).contains("merge=mps")) {
              if (dryRun) {
                return AbstractInstaller.State.OUTDATED;
              }
            } else {
              ListSequence.fromList(lines).setElement(i, ListSequence.fromList(lines).getElement(i) + " merge=mps");
            }
            addNew = false;
          }
        }
        if (addNew) {
          ListSequence.fromList(lines).addElement("*." + ext.getSuffix() + " text merge=mps");
        }
      }

      if (dryRun) {
        return AbstractInstaller.State.NOT_INSTALLED;
      }

      StringsIO.writeLines(attributesFile.getOutputStream(GitRepositoriesInstaller.class), lines);
      return AbstractInstaller.State.INSTALLED;
    } catch (IOException e) {
      return AbstractInstaller.State.NOT_INSTALLED;
    }
  }
  private static String check_mnsjzr_a0a0a0a0b0e(AbstractVcs checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }
}
