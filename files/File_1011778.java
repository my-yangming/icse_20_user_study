package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNodeId;
import java.util.List;
import com.intellij.openapi.vcs.history.VcsFileRevision;
import java.util.ArrayList;
import jetbrains.mps.smodel.persistence.lines.LineContent;
import jetbrains.mps.vcspersistence.VCSPersistenceSupport;
import org.apache.log4j.Level;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.persistence.lines.NodeLineContent;

/*package*/ final class RootHistoryModel implements Runnable {
  private static final Logger LOG = LogManager.getLogger(RootHistoryModel.class);
  private final SNodeId myRoot;
  private final List<VcsFileRevision> myFilteredRevisions = new ArrayList<VcsFileRevision>();
  private final List<VcsFileRevision> myInitialRevisions;
  private boolean myLoading;
  private final Runnable myOnUpdate;
  private final int myTotalRevisions;
  private int myProcessedRevisions;

  /*package*/ RootHistoryModel(List<VcsFileRevision> initialRevisions, SNodeId root, Runnable onUpdate) {
    myInitialRevisions = initialRevisions;
    myRoot = root;
    myOnUpdate = onUpdate;
    myTotalRevisions = initialRevisions.size();
  }

  /*package*/ boolean isLoading() {
    return myLoading;
  }

  /*package*/ List<VcsFileRevision> revisions() {
    synchronized (myFilteredRevisions) {
      return new ArrayList<VcsFileRevision>(myFilteredRevisions);
    }
  }

  /*package*/ int totalRevisions() {
    return myTotalRevisions;
  }

  /*package*/ int processedRevisions() {
    return myProcessedRevisions;
  }

  @Override
  public void run() {
    myLoading = true;
    try {
      RootHistoryModel.NodeSet ns = new RootHistoryModel.NodeSet(myRoot);
      // revision with the last revision we've analyzed content for 
      VcsFileRevision prevRevision = null;
      RootHistoryModel.ContentRange prevContentRange = null;
      // I assume first revision to be CurrentRevision with actual model/file content and myRoot node present 
      for (VcsFileRevision rev : myInitialRevisions) {
        myProcessedRevisions++;
        try {
          byte[] revContent = rev.loadContent();
          List<LineContent> lineToContentMap = VCSPersistenceSupport.getLineToContentMap(revContent);
          if (lineToContentMap == null) {
            // FIXME report somehow 
            continue;
          }
          RootHistoryModel.ContentRange contentRange = buildRanges(ns, lineToContentMap);
          if (prevRevision != null && contentRange.changedAgainst(prevContentRange)) {
            // prevRevision == null when we process the very first revision, aka CurrentRevision. All we need to do then is to record state for further steps. 
            // contentRange might be isEmpty, which indicates node addition/removal. Shall record the revision and go on, just in case the node is back in earlier revisions. 
            synchronized (myFilteredRevisions) {
              myFilteredRevisions.add(prevRevision);
            }
            // fall-through 
          }
          // if no changes, just skip this revision. Through there's no need to update prevContentRange as it's the same, do it for code simplicity 
          prevContentRange = contentRange;
          // prevRevision, however, shall always point to the processed revision 
          prevRevision = rev;
          myOnUpdate.run();
        } catch (Exception ex) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Error processing revision " + rev, ex);
          }
          // FIXME report the exception in UI 
        }
      }
    } finally {
      myLoading = false;
    }
    myOnUpdate.run();
  }

  private static RootHistoryModel.ContentRange buildRanges(RootHistoryModel.NodeSet ns, List<LineContent> lineToContentMap) {
    Map<SNodeId, Integer> firstLines = new HashMap<SNodeId, Integer>();
    RootHistoryModel.ContentRange contentRange = new RootHistoryModel.ContentRange();
    int line = 0;
    for (LineContent lc : lineToContentMap) {
      if (lc instanceof NodeLineContent) {
        SNodeId lineNodeId = lc.getNodeId();
        if (ns.isOfInterest(lineNodeId)) {
          Integer start = firstLines.remove(lineNodeId);
          if (start != null) {
            // assume it's the closing NodeLineContent for the same node id 
            // FIXME instead of this assumptions, may want to introduce "closing tag" flag into NodeLineContent to detect start/end of a node range properly 
            contentRange.recordRange(lineNodeId, start, line, lineToContentMap);
          } else {
            // first time we encountered a node of interest, record its start 
            firstLines.put(lineNodeId, line);
          }
        }
      }
      line++;
    }
    // if there were no closing NodeLineContent, assume these records are one-liners 
    for (SNodeId nid : firstLines.keySet()) {
      Integer l = firstLines.get(nid);
      contentRange.recordRange(nid, l, l, lineToContentMap);
    }
    return contentRange;
  }

  /**
   * Abstraction of a set of nodes we are interested. At the moment we are limited to a root node only
   */
  private static class NodeSet {
    private final SNodeId myRoot;

    /*package*/ NodeSet(SNodeId single) {
      myRoot = single;
    }

    public boolean isOfInterest(SNodeId nid) {
      return myRoot.equals(nid);
    }
  }

  /**
   * I don't care about line numbers but changes inside a node's range from version to version
   */
  private static class ContentRange {
    private final List<SNodeId> myNodes;
    private final List<LineContent[]> myRanges;

    /*package*/ ContentRange() {
      myNodes = new ArrayList<SNodeId>();
      myRanges = new ArrayList<LineContent[]>();
    }

    public void recordRange(SNodeId nid, int fromLine, int toLine, List<LineContent> modelContent) {
      LineContent[] arr = new LineContent[toLine - fromLine + 1];
      for (int i = 0; i < arr.length; i++) {
        arr[i] = modelContent.get(fromLine + i);
      }
      myNodes.add(nid);
      myRanges.add(arr);
    }

    public boolean isEmpty() {
      return myNodes.isEmpty();
    }

    public boolean changedAgainst(RootHistoryModel.ContentRange other) {
      if (!(myNodes.equals(other.myNodes))) {
        return true;
      }
      assert myRanges.size() == other.myRanges.size();
      for (int i = 0, x = myRanges.size(); i < x; i++) {
        LineContent[] a1 = myRanges.get(i);
        LineContent[] a2 = other.myRanges.get(i);
        if (a1.length != a2.length) {
          return true;
        }
        for (int j = 0; j < a1.length; j++) {
          if (a1[j].getClass() != a2[j].getClass()) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
