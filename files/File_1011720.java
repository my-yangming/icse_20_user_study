package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.migration.global.ProjectMigration;
import java.util.Collection;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.migration.runtime.base.MigrationModuleUtil;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.lang.migration.runtime.base.VersionFixer;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.migration.global.MigrationOptions;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.migration.runtime.base.BaseScriptReference;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.lang.migration.runtime.base.RefactoringScriptReference;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SLanguage;

public class MigrationRegistryImpl extends AbstractProjectComponent implements MigrationRegistry {
  private Project myMpsProject;
  private ProjectMigration lastProjectMigration = null;

  public MigrationRegistryImpl(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    myMpsProject = mpsProject;
  }

  @Override
  public Collection<ProjectMigration> getProjectMigrations() {
    final Wrappers._T<List<ProjectMigration>> res = new Wrappers._T<List<ProjectMigration>>();
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        res.value = ProjectMigrationsRegistry.getInstance().getMigrations();
        res.value = ListSequence.fromList(res.value).where(new IWhereFilter<ProjectMigration>() {
          public boolean accept(ProjectMigration it) {
            return it.shouldBeExecuted(myMpsProject);
          }
        }).toListSequence();
      }
    });
    return res.value;
  }

  @Override
  public Collection<ScriptApplied> getModuleMigrations(final Iterable<SModule> modules) {
    final Wrappers._T<List<ScriptApplied>> res = new Wrappers._T<List<ScriptApplied>>();
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        res.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
          public Iterable<ScriptApplied> translate(SModule module) {
            return getAllSteps(module, false);
          }
        }).toListSequence();
      }
    });
    return res.value;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationModuleUtil.getMigrateableModulesFromProject(myMpsProject);
        result.value = CollectionSequence.fromCollection(getProjectMigrations()).isNotEmpty() || CollectionSequence.fromCollection(getModuleMigrations(modules)).isNotEmpty();
      }
    });
    return result.value;
  }

  public boolean importVersionsUpdateRequired(Iterable<SModule> modules) {
    // not to check once for every module later 
    for (SModule module : ListSequence.fromList(myMpsProject.getProjectModulesWithGenerators())) {
      if (!(new VersionFixer(myMpsProject, module, true).areDepsSatisfied())) {
        return false;
      }
      if (!((module instanceof AbstractModule))) {
        continue;
      }
      ModuleDescriptor descriptor = ((AbstractModule) module).getModuleDescriptor();
      if (descriptor != null && descriptor.getLoadException() != null) {
        continue;
      }
    }

    for (SModule module : Sequence.fromIterable(modules)) {
      if (new VersionFixer(myMpsProject, module, true).importVersionsUpdateRequired()) {
        return true;
      }
    }

    return false;
  }

  public void doUpdateImportVersions(SModule module) {
    if (!(new VersionFixer(myMpsProject, module, true).areDepsSatisfied())) {
      return;
    }
    if (!((module instanceof AbstractModule))) {
      return;
    }
    ModuleDescriptor descriptor = ((AbstractModule) module).getModuleDescriptor();
    if (descriptor != null && descriptor.getLoadException() != null) {
      return;
    }

    new VersionFixer(myMpsProject, module, true).updateImportVersions();
    if (module instanceof AbstractModule) {
      (as_ufn3ol_a0a0a0g0n(module, AbstractModule.class)).save();
    }
  }

  public ProjectMigration nextProjectStep(MigrationOptions options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(myMpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    return current;
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }


  public ScriptApplied nextModuleStep(@Nullable final BaseScriptReference preferredId) {
    final Wrappers._T<ScriptApplied> result = new Wrappers._T<ScriptApplied>(null);
    myMpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // .toList is important here, makes it not to perform calculation many times 
        Project p = ProjectHelper.toMPSProject(myProject);
        Iterable<SModule> modules = MigrationModuleUtil.getMigrateableModulesFromProject(p);
        if (preferredId == null) {
          result.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
            public Iterable<ScriptApplied> translate(SModule module) {
              return getAllSteps(module, true);
            }
          }).findFirst(new IWhereFilter<ScriptApplied>() {
            public boolean accept(ScriptApplied it) {
              return canBeExecutedImmediately(it);
            }
          });
          return;
        }

        if (preferredId instanceof MigrationScriptReference) {
          final MigrationScriptReference mid = as_ufn3ol_a0a0a5a0a0a0a1a02(preferredId, MigrationScriptReference.class);
          SModule byId = Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(it)).contains(mid.getLanguage());
            }
          }).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              int ver = Math.max(0, ((AbstractModule) it).getUsedLanguageVersion(mid.getLanguage()));
              return ver == mid.getFromVersion();
            }
          }).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return canBeExecutedImmediately(new ScriptApplied(it, mid));
            }
          });
          if (byId != null) {
            result.value = new ScriptApplied(byId, mid);
            return;
          }
        } else if (preferredId instanceof RefactoringScriptReference) {
          final RefactoringScriptReference rid = as_ufn3ol_a0a0a0f0a0a0a0b0u(preferredId, RefactoringScriptReference.class);
          SModule byId = Sequence.fromIterable(modules).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(it)).contains(rid.getModule());
            }
          }).where(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              int ver = Math.max(0, ((AbstractModule) it).getDependencyVersion(rid.getModule()));
              return ver == rid.getFromVersion();
            }
          }).findFirst(new IWhereFilter<SModule>() {
            public boolean accept(SModule it) {
              return canBeExecutedImmediately(new ScriptApplied(it, rid));
            }
          });
          if (byId != null) {
            result.value = new ScriptApplied(byId, rid);
            return;
          }
        } else {
          // todo get rid of explicit class mention 
          throw new IllegalArgumentException();
        }

        // no applicable found by id 
        result.value = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, ScriptApplied>() {
          public Iterable<ScriptApplied> translate(SModule module) {
            return getAllSteps(module, true);
          }
        }).findFirst(new IWhereFilter<ScriptApplied>() {
          public boolean accept(ScriptApplied it) {
            return canBeExecutedImmediately(it);
          }
        });
      }
    });
    return result.value;
  }


  private boolean canBeExecutedImmediately(ScriptApplied script) {
    // todo remove explicit class mention 

    AbstractModule moduleToMigrate = (AbstractModule) script.getModule();
    if (script.getScriptReference() instanceof MigrationScriptReference) {
      MigrationScriptReference sr = (MigrationScriptReference) script.getScriptReference();
      int v = Math.max(0, moduleToMigrate.getUsedLanguageVersion(sr.getLanguage(), false));
      if (v != sr.getFromVersion()) {
        return false;
      }

      for (MigrationScriptReference s : Sequence.fromIterable(sr.resolve(myMpsProject, true).executeAfter())) {
        if (needsToBeApplied(s, moduleToMigrate)) {
          return false;
        }
      }

      for (MigrationScriptReference s : Sequence.fromIterable(sr.resolve(myMpsProject, true).requiresData())) {
        for (SModule dep : SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(moduleToMigrate))) {
          if (needsToBeApplied(s, dep)) {
            return false;
          }
        }
      }
      return true;
    }
    if (script.getScriptReference() instanceof RefactoringScriptReference) {
      RefactoringScriptReference sr = (RefactoringScriptReference) script.getScriptReference();
      int v = Math.max(0, moduleToMigrate.getDependencyVersion(sr.getModule(), false));
      if (v != sr.getFromVersion()) {
        return false;
      }

      for (RefactoringScriptReference s : Sequence.fromIterable(sr.resolve(myMpsProject, true).getExecuteAfter())) {
        if (needsToBeApplied(s, moduleToMigrate)) {
          return false;
        }
      }
      return true;
    }
    throw new IllegalArgumentException();
  }

  private boolean needsToBeApplied(MigrationScriptReference ref, SModule m) {
    if (!(SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(m)).contains(ref.getLanguage()))) {
      return false;
    }
    int dv = Math.max(0, ((AbstractModule) m).getUsedLanguageVersion(ref.getLanguage(), false));
    return dv <= ref.getFromVersion();
  }

  private boolean needsToBeApplied(RefactoringScriptReference ref, SModule m) {
    if (!(SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(m)).contains(ref.getModule()))) {
      return false;
    }
    int dv = Math.max(0, ((AbstractModule) m).getDependencyVersion(ref.getModule(), false));
    return dv <= ref.getFromVersion();
  }

  private Iterable<ScriptApplied> getAllSteps(SModule module, boolean firstOnly) {
    List<ScriptApplied> result = ListSequence.fromList(new ArrayList<ScriptApplied>());
    for (SLanguage lang : SetSequence.fromSet(MigrationModuleUtil.getUsedLanguages(module))) {
      int currentLangVersion = lang.getLanguageVersion();
      int ver = ((AbstractModule) module).getUsedLanguageVersion(lang, false);

      ver = Math.max(ver, 0);
      currentLangVersion = Math.max(currentLangVersion, 0);

      for (int i = ver; i < currentLangVersion; i++) {
        ListSequence.fromList(result).addElement(new ScriptApplied(module, new MigrationScriptReference(lang, i)));
        if (firstOnly) {
          break;
        }
      }
    }
    for (SModule dep : SetSequence.fromSet(MigrationModuleUtil.getModuleDependencies(module))) {
      int currentDepVersion = ((AbstractModule) dep).getModuleVersion();
      int ver = ((AbstractModule) module).getDependencyVersion(dep, false);

      ver = Math.max(ver, 0);
      currentDepVersion = Math.max(currentDepVersion, 0);

      for (int i = ver; i < currentDepVersion; i++) {
        ListSequence.fromList(result).addElement(new ScriptApplied(module, new RefactoringScriptReference(dep, i)));
        if (firstOnly) {
          break;
        }
      }
    }
    return result;
  }

  private static <T> T as_ufn3ol_a0a0a0g0n(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ufn3ol_a0a0a5a0a0a0a1a02(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_ufn3ol_a0a0a0f0a0a0a0b0u(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
