package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.ConcurrentMap;
import jetbrains.mps.vfs.refresh.FileSystemListener;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vfs.path.Path;
import jetbrains.mps.vfs.refresh.FileListener;
import org.jetbrains.annotations.Nullable;
import java.util.Collections;

/**
 * Stores a tree of listeners stored per file.
 * Supposed to be thread-safe
 */
public class FileSystemListenersContainer {
  private final ReadWriteLock myLock = new ReentrantReadWriteLock();
  private final FileSystemListenersContainer.Node myRootNode = new FileSystemListenersContainer.Node(null, null);
  private final ConcurrentMap<FileSystemListener, String> myListener2Path = new ConcurrentHashMap<FileSystemListener, String>();

  /*package*/ static class ListenersForPath {
    /*package*/ final List<FileSystemListener> ancestorListeners = ListSequence.fromList(new ArrayList<FileSystemListener>());
    /*package*/ final List<FileSystemListener> concretePathListeners = ListSequence.fromList(new ArrayList<FileSystemListener>());
    /*package*/ final List<FileSystemListener> descendantsListeners = ListSequence.fromList(new ArrayList<FileSystemListener>());
  }

  public FileSystemListenersContainer() {
  }

  public void addListener(@NotNull FileSystemListener listener) {
    if (myListener2Path.containsKey(listener)) {
      return;
    }
    IFile fileToListen = listener.getFileToListen();
    if (fileToListen == null) {
      return;
    }
    String path = fileToListen.getPath();
    if (myListener2Path.putIfAbsent(listener, path) != null) {
      return;
    }

    FileSystemListenersContainer.Node currentNode = myRootNode;

    myLock.writeLock().lock();
    try {
      for (String s : normalizeAndSplit(path)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        currentNode = currentNode.child(s, true);
      }
      currentNode.addListener(listener);
    } finally {
      myLock.writeLock().unlock();
    }
  }

  public void removeListener(@NotNull FileSystemListener listener) {
    String path = myListener2Path.get(listener);
    if (path == null) {
      return;
    }

    FileSystemListenersContainer.Node currentNode = myRootNode;
    myLock.writeLock().lock();
    try {
      for (String s : normalizeAndSplit(path)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        currentNode = currentNode.child(s, false);
        if (currentNode == null) {
          return;
        }
      }
      currentNode.removeListener(listener);
    } finally {
      myLock.writeLock().unlock();
    }
    myListener2Path.remove(listener);
  }

  @NotNull
  public FileSystemListenersContainer.ListenersForPath getListenersForPath(String eventPath) {
    FileSystemListenersContainer.Node currentNode = myRootNode;
    FileSystemListenersContainer.ListenersForPath result = new FileSystemListenersContainer.ListenersForPath();
    myLock.readLock().lock();
    try {
      for (String s : normalizeAndSplit(eventPath)) {
        if ((s == null || s.length() == 0)) {
          continue;
        }
        currentNode.addListenersTo(result.ancestorListeners);
        currentNode = currentNode.child(s, false);
        if (currentNode == null) {
          return result;
        }
      }
      currentNode.addListenersTo(result.concretePathListeners);
      traverseChildrenOfPath(eventPath, result.descendantsListeners, currentNode);
    } finally {
      myLock.readLock().unlock();
    }
    return result;
  }

  private void traverseChildrenOfPath(String eventPath, @NotNull List<FileSystemListener> result, @NotNull FileSystemListenersContainer.Node eventPathNode) {
    List<FileSystemListenersContainer.Node> children = eventPathNode.getChildren();
    for (FileSystemListenersContainer.Node child : ListSequence.fromList(children)) {
      child.addListenersTo(result);
      traverseChildrenOfPath(eventPath, result, child);
    }
  }

  private String[] normalizeAndSplit(@NotNull String path) {
    String normalized = FileUtil.normalize(path);
    return normalized.split(Path.UNIX_SEPARATOR);
  }

  public boolean contains(@NotNull FileListener listener) {
    return myListener2Path.containsKey(listener);
  }

  private static final class Node {
    @Nullable
    private List<FileSystemListener> myListeners;
    private final String myPathPart;
    private final List<FileSystemListenersContainer.Node> myChildren = new ArrayList<FileSystemListenersContainer.Node>(4);
    @Nullable
    private final FileSystemListenersContainer.Node myParent;

    /*package*/ Node(String pathPart, @Nullable FileSystemListenersContainer.Node parent) {
      myParent = parent;
      myPathPart = pathPart;
    }

    @NotNull
    /*package*/ List<FileSystemListenersContainer.Node> getChildren() {
      if (myChildren == null) {
        return Collections.emptyList();
      }
      return Collections.unmodifiableList(myChildren);
    }

    /*package*/ FileSystemListenersContainer.Node child(String part, boolean create) {
      // we keep children list sorted and use binary search 
      int index = childIndex(part);
      if (index >= 0) {
        return myChildren.get(index);
      }
      if (create) {
        FileSystemListenersContainer.Node child = new FileSystemListenersContainer.Node(part, this);
        myChildren.add(-index - 1, child);
        return child;
      }
      return null;
    }

    private void deleteIfEmpty() {
      if (myParent == null || !(myChildren.isEmpty())) {
        return;
      }
      if (myListeners != null && !(myListeners.isEmpty())) {
        return;
      }

      myListeners = null;
      myParent.myChildren.remove(this);
      myParent.deleteIfEmpty();
    }

    private int childIndex(String pathPart) {
      int low = 0;
      int high = myChildren.size() - 1;
      while (low <= high) {
        int mid = (low + high) >>> 1;
        FileSystemListenersContainer.Node c = myChildren.get(mid);
        int cmp = pathPart.compareTo(c.myPathPart);
        if (cmp < 0) {
          high = mid - 1;
        } else if (cmp > 0) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return -(low + 1);
    }

    /*package*/ void addListenersTo(List<FileSystemListener> res) {
      if (myListeners != null) {
        res.addAll(myListeners);
      }
    }

    /*package*/ void addListener(@NotNull FileSystemListener l) {
      if (myListeners == null) {
        myListeners = new ArrayList<FileSystemListener>(4);
      }
      myListeners.add(l);
    }

    /*package*/ void removeListener(@NotNull FileSystemListener l) {
      if (myListeners != null && myListeners.remove(l)) {
        deleteIfEmpty();
      }
    }
  }
}
