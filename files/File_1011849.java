package jetbrains.mps.baseLanguage.math.runtime;

/*Generated by MPS */

import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;

public class Interval<T extends Comparable> implements Iterable<T> {
  private static final Map<Class, Interval.IteratorFactory> ourIteratorFactories = new HashMap<Class, Interval.IteratorFactory>();
  private final T myStart;
  private final T myEnd;
  private final boolean myStartIncluded;
  private final boolean myEndIncluded;
  public Interval(T start, boolean startIncluded, T end, boolean endIncluded) {
    if ((start == null && startIncluded) || (end == null && endIncluded)) {
      throw new IllegalArgumentException();
    }
    if (start != null && end != null) {
      if (end.compareTo(start) < 0) {
        throw new IllegalArgumentException();
      }
      if (start.compareTo(end) == 0 && (!(startIncluded) || !(endIncluded))) {
        throw new IllegalArgumentException();
      }
    }
    myStart = start;
    myEnd = end;
    myStartIncluded = startIncluded;
    myEndIncluded = endIncluded;
  }
  public Interval(T start, T end) {
    this(start, start != null, end, end != null);
  }
  public T getStart() {
    return myStart;
  }
  public T getEnd() {
    return myEnd;
  }
  public boolean isStartIncluded() {
    return myStartIncluded;
  }
  public boolean isEndIncluded() {
    return myEndIncluded;
  }
  public boolean contains(T value) {
    if (myStart != null) {
      int deltaStart = myStart.compareTo(value);
      if (myStartIncluded) {
        if (deltaStart > 0) {
          return false;
        }
      } else {
        if (deltaStart >= 0) {
          return false;
        }
      }
    }
    if (myEnd != null) {
      int deltaEnd = myEnd.compareTo(value);
      if (myEndIncluded) {
        if (deltaEnd < 0) {
          return false;
        }
      } else {
        if (deltaEnd <= 0) {
          return false;
        }
      }
    }
    return true;
  }
  @Override
  public Iterator<T> iterator() {
    if (myStart == null || myEnd == null) {
      throw new UnsupportedOperationException();
    }
    Interval.IteratorFactory<T> factory = ourIteratorFactories.get(myStart.getClass());
    if (factory == null) {
      throw new UnsupportedOperationException();
    }
    return factory.iterator(myStart, myStartIncluded, myEnd, myEndIncluded);
  }
  private interface IteratorFactory<T> {
    Iterator<T> iterator(T start, boolean startIncluded, T end, boolean endIncluded);
  }
  static {
    ourIteratorFactories.put(Character.class, new Interval.IteratorFactory<Character>() {
      @Override
      public Iterator<Character> iterator(final Character start, final boolean startIncluded, final Character end, final boolean endIncluded) {
        return new Iterator<Character>() {
          {
            if (startIncluded) {
              myCurrent = start;
            } else {
              myCurrent = (char) (start + 1);
            }
          }
          private Character myCurrent;
          @Override
          public boolean hasNext() {
            if (endIncluded) {
              return end.compareTo(myCurrent) >= 0;
            } else {
              return end.compareTo(myCurrent) > 0;
            }
          }
          @Override
          public Character next() {
            return (char) myCurrent++;
          }
          @Override
          public void remove() {
            throw new UnsupportedOperationException();
          }
        };
      }
    });
    ourIteratorFactories.put(Byte.class, new Interval.IteratorFactory<Byte>() {
      @Override
      public Iterator<Byte> iterator(final Byte start, final boolean startIncluded, final Byte end, final boolean endIncluded) {
        return new Iterator<Byte>() {
          {
            if (startIncluded) {
              myCurrent = start;
            } else {
              myCurrent = (byte) (start + 1);
            }
          }
          private Byte myCurrent;
          @Override
          public boolean hasNext() {
            if (endIncluded) {
              return end.compareTo(myCurrent) >= 0;
            } else {
              return end.compareTo(myCurrent) > 0;
            }
          }
          @Override
          public Byte next() {
            return (byte) myCurrent++;
          }
          @Override
          public void remove() {
            throw new UnsupportedOperationException();
          }
        };
      }
    });
    ourIteratorFactories.put(Short.class, new Interval.IteratorFactory<Short>() {
      @Override
      public Iterator<Short> iterator(final Short start, final boolean startIncluded, final Short end, final boolean endIncluded) {
        return new Iterator<Short>() {
          {
            if (startIncluded) {
              myCurrent = start;
            } else {
              myCurrent = (short) (start + 1);
            }
          }
          private Short myCurrent;
          @Override
          public boolean hasNext() {
            if (endIncluded) {
              return end.compareTo(myCurrent) >= 0;
            } else {
              return end.compareTo(myCurrent) > 0;
            }
          }
          @Override
          public Short next() {
            return myCurrent++;
          }
          @Override
          public void remove() {
            throw new UnsupportedOperationException();
          }
        };
      }
    });
    ourIteratorFactories.put(Integer.class, new Interval.IteratorFactory<Integer>() {
      @Override
      public Iterator<Integer> iterator(final Integer start, final boolean startIncluded, final Integer end, final boolean endIncluded) {
        return new Iterator<Integer>() {
          {
            if (startIncluded) {
              myCurrent = start;
            } else {
              myCurrent = start + 1;
            }
          }
          private Integer myCurrent;
          @Override
          public boolean hasNext() {
            if (endIncluded) {
              return end.compareTo(myCurrent) >= 0;
            } else {
              return end.compareTo(myCurrent) > 0;
            }
          }
          @Override
          public Integer next() {
            return myCurrent++;
          }
          @Override
          public void remove() {
            throw new UnsupportedOperationException();
          }
        };
      }
    });
    ourIteratorFactories.put(Long.class, new Interval.IteratorFactory<Long>() {
      @Override
      public Iterator<Long> iterator(final Long start, final boolean startIncluded, final Long end, final boolean endIncluded) {
        return new Iterator<Long>() {
          {
            if (startIncluded) {
              myCurrent = start;
            } else {
              myCurrent = start + 1;
            }
          }
          private Long myCurrent;
          @Override
          public boolean hasNext() {
            if (endIncluded) {
              return end.compareTo(myCurrent) >= 0;
            } else {
              return end.compareTo(myCurrent) > 0;
            }
          }
          @Override
          public Long next() {
            return myCurrent++;
          }
          @Override
          public void remove() {
            throw new UnsupportedOperationException();
          }
        };
      }
    });
  }
}
