package jetbrains.mps.internal.collections.runtime;

/*Generated by MPS */

import java.util.List;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.ListIterator;
import jetbrains.mps.baseLanguage.closures.runtime.AdapterClass;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Collections;

public abstract class AbstractListSequence<T> extends AbstractCollectionSequence<T> implements IListSequence<T>, List<T>, Serializable {
  private static final long serialVersionUID = -2967185763228867218L;
  private List<T> list;
  protected AbstractListSequence(List<T> list) {
    setList(list);
  }
  protected AbstractListSequence(AbstractListSequence<T> other) {
    setList(new ArrayList<T>(other.getList()));
  }
  protected AbstractListSequence() {
  }
  @Override
  public void add(int index, T element) {
    getList().add(index, element);
  }
  @Override
  public boolean addAll(int index, Collection<? extends T> c) {
    return getList().addAll(index, c);
  }
  @Override
  public int indexOf(Object o) {
    return getList().indexOf(o);
  }
  @Override
  public boolean isEmpty() {
    return getList().isEmpty();
  }
  @Override
  public T get(int index) {
    return getList().get(index);
  }
  @Override
  public int lastIndexOf(Object o) {
    return getList().lastIndexOf(o);
  }
  @Override
  public ListIterator<T> listIterator() {
    return getList().listIterator();
  }
  @Override
  public ListIterator<T> listIterator(int index) {
    return getList().listIterator(index);
  }
  @Override
  public T remove(int index) {
    return getList().remove(index);
  }
  @Override
  public T set(int index, T element) {
    return getList().set(index, element);
  }
  @Override
  public List<T> subList(int fromIndex, int toIndex) {
    return getList().subList(fromIndex, toIndex);
  }
  @Override
  public T first() {
    if (getList().size() > 0) {
      return getList().get(0);
    }
    if (Sequence.NULL_WHEN_EMPTY) {
      return null;
    } else {
      throw new IndexOutOfBoundsException("Empty list");
    }
  }
  @Override
  public T last() {
    if (getList().size() > 0) {
      return getList().get(getList().size() - 1);
    }
    if (Sequence.NULL_WHEN_EMPTY) {
      return null;
    } else {
      throw new IndexOutOfBoundsException("Empty list");
    }
  }
  @Override
  public boolean isNotEmpty() {
    return !((getList().isEmpty()));
  }
  @Override
  public T removeElementAt(int idx) {
    if (Sequence.NULL_WHEN_EMPTY) {
      if (size() == 0 && (idx == 0 || idx == -1)) {
        return null;
      }
    }
    return remove(idx);
  }
  @Override
  public T removeLastElement() {
    if (Sequence.NULL_WHEN_EMPTY) {
      if (size() == 0) {
        return null;
      }
    }
    return remove(size() - 1);
  }
  @Override
  public T insertElement(int idx, T t) {
    if (Sequence.IGNORE_NULL_VALUES) {
      if (t == null) {
        return null;
      }
    }
    add(idx, t);
    return t;
  }
  @Override
  public T getElement(int idx) {
    if (Sequence.NULL_WHEN_EMPTY) {
      if (size() == 0 && (idx == 0 || idx == -1)) {
        return null;
      }
    }
    return get(idx);
  }
  @Override
  public T setElement(int idx, T t) {
    if (Sequence.IGNORE_NULL_VALUES) {
      if (t == null) {
        return null;
      }
    }
    if (Sequence.NULL_WHEN_EMPTY) {
      if (size() == 0 && (idx == 0 || idx == -1)) {
        return null;
      }
    }
    set(idx, t);
    return t;
  }
  @Override
  public IListSequence<T> addSequence(ISequence<? extends T> seq) {
    return (IListSequence<T>) super.addSequence(seq);
  }
  @Override
  public IListSequence<T> removeSequence(ISequence<? extends T> seq) {
    return (IListSequence<T>) super.removeSequence(seq);
  }
  @Override
  public IListSequence<T> removeWhere(@AdapterClass(value = "IWhereFilter") _FunctionTypes._return_P1_E0<? extends Boolean, ? super T> filter) {
    return (IListSequence<T>) super.removeWhere(filter);
  }
  @SuppressWarnings(value = "unchecked")
  @Override
  public T[] toGenericArray() {
    return (T[]) getList().toArray();
  }
  @SuppressWarnings(value = "unchecked")
  @Override
  public T[] toGenericArray(Class<T> runtimeClass) {
    T[] arr = (T[]) ArrayUtils.newArrayInstance(runtimeClass, getList().size());
    return getList().toArray(arr);
  }
  @Override
  public List<T> toList() {
    return this;
  }
  @Override
  public IListSequence<T> toListSequence() {
    return this;
  }
  /*package*/ void _reverse() {
    Collections.reverse(getList());
  }
  @Override
  protected List<T> getCollection() {
    return list;
  }
  protected List<T> getList() {
    return list;
  }
  private void setList(List<T> list) {
    this.list = list;
  }
}
