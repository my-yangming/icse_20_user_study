package jetbrains.mps.vcs.diff.ui.common;

/*Generated by MPS */

import com.intellij.ui.treeStructure.SimpleTree;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.actionSystem.DataKey;
import com.intellij.openapi.util.Ref;
import org.jetbrains.mps.openapi.model.SNodeId;
import java.util.List;
import jetbrains.mps.workbench.action.BaseAction;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import com.intellij.ui.ColoredTreeCellRenderer;
import javax.swing.JTree;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionPlaces;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Collections;
import java.util.Enumeration;
import org.jetbrains.annotations.Nullable;
import javax.swing.tree.TreePath;
import java.util.Objects;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import javax.swing.tree.DefaultTreeModel;
import com.intellij.util.ui.tree.TreeUtil;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.ide.icons.IdeIcons;
import javax.swing.Icon;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.ide.icons.GlobalIconManager;
import javax.swing.tree.DefaultMutableTreeNode;
import com.intellij.ui.SimpleTextAttributes;
import java.awt.Color;

public abstract class DiffModelTree extends SimpleTree implements DataProvider {
  public static DataKey<Ref<SNodeId>> NODE_ID_DATAKEY = DataKey.create("MPS_SNodeId");
  private List<DiffModelTree.RootTreeNode> myRootNodes;
  private Iterable<BaseAction> myActions;
  private final SRepository myRepo;

  public DiffModelTree(SRepository repo) {
    // FIXME This code deserves a refactoring much like MergeModelsPanel, as there's unlikely need for repository lock when we diff detached models. 
    // Besides, it's ugly to build a tree during construction time! 
    myRepo = repo;
    rebuildNow();
    // FIXME oh, no, abstract method called from a constructor! 
    myActions = getRootActions();
    Sequence.fromIterable(myActions).visitAll(new IVisitor<BaseAction>() {
      public void visit(BaseAction a) {
        a.registerCustomShortcutSet(a.getShortcutSet(), DiffModelTree.this);
      }
    });
    setCellRenderer(new ColoredTreeCellRenderer() {
      @Override
      public void customizeCellRenderer(JTree p0, final Object value, boolean p2, boolean p3, boolean p4, int p5, boolean p6) {
        if (value instanceof DiffModelTree.TreeNode) {
          // FIXME this code is poor, need to check TreeNode subclasses if they really care to have model access 
          myRepo.getModelAccess().runReadAction(new Runnable() {
            public void run() {
              ((DiffModelTree.TreeNode) value).doUpdatePresentation();
            }
          });
          ((DiffModelTree.TreeNode) value).renderTreeNode(this);
        }
      }
    });
    setPopupGroup(ActionUtils.groupFromActions(Sequence.fromIterable(myActions).toGenericArray(BaseAction.class)), ActionPlaces.CHANGES_VIEW_POPUP);
    // listen for selection changes 
    getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {
      public void valueChanged(TreeSelectionEvent e) {
        DiffModelTree.RootTreeNode[] node = getSelectedNodes(DiffModelTree.RootTreeNode.class, null);
        if (node == null || node.length != 1) {
          onUnselect();
        } else {
          onSelectRoot(node[0].getRootId());
        }
      }
    });
  }

  protected DiffModelTree.TreeNode rebuild() {
    DiffModelTree.ModelTreeNode modelNode = new DiffModelTree.ModelTreeNode();
    myRootNodes = Sequence.fromIterable(getAffectedRoots()).where(new IWhereFilter<SNodeId>() {
      public boolean accept(SNodeId r) {
        return r != null;
      }
    }).select(new ISelector<SNodeId, DiffModelTree.RootTreeNode>() {
      public DiffModelTree.RootTreeNode select(SNodeId r) {
        return new DiffModelTree.RootTreeNode(r);
      }
    }).sort(new ISelector<DiffModelTree.RootTreeNode, String>() {
      public String select(DiffModelTree.RootTreeNode rtn) {
        return rtn.myVirtualPackage + "|" + rtn.myPresentation;
      }
    }, true).toListSequence();
    for (DiffModelTree.RootTreeNode rtn : ListSequence.fromList(myRootNodes)) {
      DiffModelTree.TreeNode parentNode = modelNode;
      if (isNotEmptyString(rtn.myVirtualPackage)) {
        for (final String sub : Sequence.fromArray(rtn.myVirtualPackage.split("\\."))) {
          Iterable<DiffModelTree.TreeNode> children = Collections.list(((Enumeration) parentNode.children()));
          DiffModelTree.TreeNode child = Sequence.fromIterable(children).findFirst(new IWhereFilter<DiffModelTree.TreeNode>() {
            public boolean accept(DiffModelTree.TreeNode c) {
              return c instanceof DiffModelTree.PackageTreeNode && sub.equals(c.getText());
            }
          });
          if (child == null) {
            child = new DiffModelTree.PackageTreeNode(sub);
            parentNode.add(child);
          }
          parentNode = child;
        }
      }
      parentNode.add(rtn);
    }
    if (Sequence.fromIterable(getAffectedRoots()).any(new IWhereFilter<SNodeId>() {
      public boolean accept(SNodeId r) {
        return r == null;
      }
    })) {
      DiffModelTree.RootTreeNode metadataNode = new DiffModelTree.MetadataTreeNode();
      ListSequence.fromList(myRootNodes).addElement(metadataNode);
      modelNode.add(metadataNode);
    }
    return modelNode;
  }

  public void setSelected(@Nullable SNodeId rootId) {
    // todo: find path by rootId 
    TreePath path = null;
    for (int i = 0; i < getRowCount(); ++i) {
      DiffModelTree.RootTreeNode node = as_5x0uld_a0a0a2a9(getPathForRow(i).getLastPathComponent(), DiffModelTree.RootTreeNode.class);
      if (node != null && Objects.equals(node.getRootId(), rootId)) {
        path = getPathForRow(i);
        break;
      }
    }

    if (path != null) {
      expandPath(path);
      setSelectionPath(path);
      scrollPathToVisible(path);
    }
  }

  public void rebuildLater() {
    rebuildNow();
  }

  public void rebuildNow() {
    DiffModelTree.TreeNode root = new ModelAccessHelper(myRepo).runReadAction(new Computable<DiffModelTree.TreeNode>() {
      public DiffModelTree.TreeNode compute() {
        return rebuild();
      }
    });
    setModel(new DefaultTreeModel(root));
    setRootVisible(true);
    TreeUtil.expandAll(this);
    setSelectionRow(0);
  }

  protected abstract Iterable<SNodeId> getAffectedRoots();
  protected abstract Iterable<SModel> getModels();
  protected abstract void updateRootCustomPresentation(@NotNull DiffModelTree.RootTreeNode rootTreeNode);
  protected abstract Iterable<BaseAction> getRootActions();
  protected boolean isMultipleRootNames() {
    return false;
  }
  protected void onUnselect() {
  }
  protected void onSelectRoot(@Nullable SNodeId rootId) {
  }
  private DiffModelTree.RootTreeNode findRootNode(@Nullable final SNodeId nodeId) {
    return ListSequence.fromList(myRootNodes).findFirst(new IWhereFilter<DiffModelTree.RootTreeNode>() {
      public boolean accept(DiffModelTree.RootTreeNode r) {
        return Objects.equals(nodeId, r.myRootId);
      }
    });
  }
  private int advanceIndex(int index, boolean next) {
    return (next ? index + 1 : index - 1);
  }
  public boolean hasNeighbour(SNodeId nodeId, boolean next) {
    int index = advanceIndex(ListSequence.fromList(myRootNodes).indexOf(findRootNode(nodeId)), next);
    return index >= 0 && index < ListSequence.fromList(myRootNodes).count();
  }
  @Nullable
  public SNodeId getNeighbourRoot(@Nullable SNodeId nodeId, boolean next) {
    int index = advanceIndex(ListSequence.fromList(myRootNodes).indexOf(findRootNode(nodeId)), next);
    assert index >= 0 && index < ListSequence.fromList(myRootNodes).count();
    return ListSequence.fromList(myRootNodes).getElement(index).myRootId;
  }
  public String getNameForRoot(@Nullable SNodeId nodeId) {
    return check_5x0uld_a0a62(findRootNode(nodeId), this);
  }
  @Nullable
  @Override
  public Object getData(@NonNls String dataId) {
    if (NODE_ID_DATAKEY.is(dataId)) {
      DiffModelTree.RootTreeNode[] selectedNodes = getSelectedNodes(DiffModelTree.RootTreeNode.class, null);
      if (selectedNodes != null && selectedNodes.length > 0) {
        return new Ref<SNodeId>(selectedNodes[0].getRootId());
      }
    }
    return null;
  }
  public class ModelTreeNode extends DiffModelTree.TreeNode {
    public ModelTreeNode() {
      super("model");
      String modelName = SModelOperations.getModelName(Sequence.fromIterable(getModels()).findFirst(new IWhereFilter<SModel>() {
        public boolean accept(SModel it) {
          return isNotEmptyString(SModelOperations.getModelName(it));
        }
      }));
      if (!((modelName == null || modelName.length() == 0))) {
        setText(modelName);
      }
      setIcon(IdeIcons.MODEL_ICON);
    }
  }
  private class PackageTreeNode extends DiffModelTree.TreeNode {
    private PackageTreeNode(@NotNull String packageName) {
      super(packageName);
    }
  }
  public class RootTreeNode extends DiffModelTree.TreeNode {
    private SNodeId myRootId;
    private String myPresentation = null;
    private String myVirtualPackage = null;

    public RootTreeNode(SNodeId rootId) {
      super("" + rootId);
      myRootId = rootId;
      doUpdatePresentation();
    }
    @Override
    protected void doUpdatePresentation() {
      myPresentation = null;
      Icon icon = null;
      for (SModel model : Sequence.fromIterable(getModels())) {
        SNode root = model.getNode(myRootId);
        if (root != null && SNodeOperations.getParent(root) == null) {
          String presentation = root.getPresentation();
          if (myPresentation == null) {
            myPresentation = presentation;
          } else if (isMultipleRootNames()) {
            if (("/ " + myPresentation + " /").contains("/ " + presentation + " /")) {
            } else {
              myPresentation += " / " + presentation;
            }
          }

          if (myVirtualPackage == null) {
            myVirtualPackage = (SPropertyOperations.getString(root, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x115eca8579fL, "virtualPackage")) == null ? "" : SPropertyOperations.getString(root, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x115eca8579fL, "virtualPackage")));
          }
          if (icon == null) {
            icon = GlobalIconManager.getInstance().getIconFor(root);
          }
        }
      }
      setText("" + myPresentation);
      setIcon(icon);
      updateRootCustomPresentation(this);
    }
    @Nullable
    public SNodeId getRootId() {
      return myRootId;
    }
    public String getPresentation() {
      return myPresentation;
    }
  }
  public class MetadataTreeNode extends DiffModelTree.RootTreeNode {
    public MetadataTreeNode() {
      super(null);
      setText("Model Properties");
      doUpdatePresentation();
    }
    @Override
    protected void doUpdatePresentation() {
      setIcon(IdeIcons.PROPERTIES_ICON);
      updateRootCustomPresentation(this);
    }
    @Override
    public String getPresentation() {
      return "Model Properties";
    }
  }
  public abstract class TreeNode extends DefaultMutableTreeNode {
    @NotNull
    private String myText;
    private int myTextStyle = SimpleTextAttributes.STYLE_PLAIN;
    private String myAdditionalText;
    private String myTooltipText;
    private Icon myIcon;
    private Color myColor;

    public TreeNode(@NotNull String text) {
      myText = text;
    }
    public void renderTreeNode(ColoredTreeCellRenderer coloredRenderer) {
      coloredRenderer.append(getText(), new SimpleTextAttributes(myTextStyle, getColor()));
      if ((myAdditionalText != null && myAdditionalText.length() > 0)) {
        coloredRenderer.append(" (" + myAdditionalText + ")", new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, Color.GRAY));
      }
      coloredRenderer.setToolTipText(myTooltipText);
      coloredRenderer.setIcon(getIcon());
    }
    protected void doUpdatePresentation() {
    }
    @NotNull
    public String getText() {
      return myText;
    }
    public void setText(@NotNull String text) {
      myText = text;
    }
    public String getAdditionalText() {
      return myAdditionalText;
    }
    public void setAdditionalText(String additionalText) {
      myAdditionalText = additionalText;
    }
    public String getTooltipText() {
      return myTooltipText;
    }
    public void setTooltipText(String tooltipText) {
      myTooltipText = tooltipText;
    }
    public Icon getIcon() {
      return myIcon;
    }
    public void setIcon(Icon icon) {
      myIcon = icon;
    }
    public Color getColor() {
      return myColor;
    }
    public void setColor(Color color) {
      myColor = color;
    }
    public void setTextStyle(int textStyle) {
      myTextStyle = textStyle;
    }
  }
  private static String check_5x0uld_a0a62(DiffModelTree.RootTreeNode checkedDotOperand, DiffModelTree checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getPresentation();
    }
    return null;
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
  private static <T> T as_5x0uld_a0a0a2a9(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
