package jetbrains.mps.internal.make.runtime.util;

/*Generated by MPS */

import java.util.regex.Pattern;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.io.File;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class DirUtil {
  private static Pattern URL = Pattern.compile("[a-zA-Z]://(.*)");
  private static final char SLASH_CHAR = '/';
  private static final String SLASH = "/";
  public static String[] sortDirs(Iterable<String> dirPaths) {
    return Sequence.fromIterable(dirPaths).select(new ISelector<String, String>() {
      public String select(String p) {
        return asDir(straighten(urlToPath(p)));
      }
    }).sort(new ISelector<String, String>() {
      public String select(String p) {
        return p;
      }
    }, true).toGenericArray(String.class);
  }
  public static int findPrefixAsDir(String dirPath, String[] sortedPaths) {
    String dir = asDir(straighten(urlToPath(dirPath)));
    int idx = Arrays.binarySearch(sortedPaths, dir);
    int absIdx = (idx < 0 ? -2 - idx : idx);
    if (absIdx >= 0 && absIdx < sortedPaths.length && startsWith(dir, sortedPaths[absIdx])) {
      return absIdx;
    }
    return idx;
  }
  public static String normalize(String path) {
    return straighten(urlToPath(path));
  }
  public static String normalizeAsDir(String dirPath) {
    return asDir(straighten(urlToPath(dirPath)));
  }
  public static String asDir(String path) {
    return (path.endsWith(SLASH) ? path : path + SLASH);
  }
  public static String urlToPath(String maybeUrl) {
    Matcher m = URL.matcher(maybeUrl);
    return (m.matches() ? m.group(1) : maybeUrl);
  }
  public static String straighten(String syspath) {
    return syspath.replace(File.separatorChar, SLASH_CHAR);
  }
  public static boolean startsWith(String path, String prefix) {
    return path.startsWith(prefix) && (path.length() == prefix.length() || prefix.endsWith(SLASH) || path.charAt(prefix.length()) == SLASH_CHAR);
  }
  /**
   * Deduce common parent directory given two normalized/straighten paths
   * 
   * @param path1 first path
   * @param path2 second path
   * @return empty text if directory paths don't share common prefix, common prefix including trailing slash otherwise
   */
  @NotNull
  /*package*/ static String commonDirPrefix(@NotNull String path1, @NotNull String path2) {
    int lastMatchedSlash = -1;
    for (int i = 0, x = Math.min(path1.length(), path2.length()); i < x; i++) {
      char c = path1.charAt(i);
      if (c != path2.charAt(i)) {
        break;
      }
      if (c == SLASH_CHAR) {
        lastMatchedSlash = i;
      }
    }
    return (lastMatchedSlash == -1 ? "" : path1.substring(0, lastMatchedSlash + 1));
  }
  public static String withoutPrefix(String path, String prefix) {
    if (!(startsWith(path, prefix))) {
      throw new IllegalArgumentException("invalid prefix");
    }
    if (path.length() == prefix.length()) {
      return "";
    }
    int prefixLength = prefix.length();
    if (path.charAt(prefix.length()) == SLASH_CHAR) {
      prefixLength++;
    }
    return path.substring(prefixLength);
  }
  public static boolean same(String path1, String path2) {
    if (path1.equals(path2)) {
      return true;
    }
    if (path1.length() == path2.length()) {
      return false;
    }
    if (path1.length() > path2.length()) {
      {
        Tuples._2<String, String> _tmp_rkp2iv_a0c0n = MultiTuple.<String,String>from(path2, path1);
        path1 = _tmp_rkp2iv_a0c0n._0();
        path2 = _tmp_rkp2iv_a0c0n._1();
      }
    }
    return path2.startsWith(path1) && path2.charAt(path1.length()) == SLASH_CHAR && (path2.length() - path1.length() == 1);
  }
}
