package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.refactoring.participant.RefactoringUI;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SModule;

public class BaseRefactoringScript implements RefactoringScript {
  private String myCaption;
  private RefactoringScriptReference myDescriptor;
  private List<RefactoringScriptReference> myExecuteAfter;
  private List<RefactoringPartImpl> myParts;
  private RefactoringSession mySession;
  private _FunctionTypes._void_P1_E0<? super Runnable> myRunner;
  private _FunctionTypes._void_P4_E0<? super RefactoringUI, ? super RefactoringParticipant.PersistentRefactoringParticipant, ? super Iterable<SNode>, ? super Map<SNode, SNode>> myRefactoringProcessor;
  public BaseRefactoringScript(String caption, RefactoringScriptReference descriptor, List<RefactoringScriptReference> executeAfter, List<RefactoringPartImpl> parts) {
    myCaption = caption;
    myDescriptor = descriptor;
    myExecuteAfter = ListSequence.fromListWithValues(new ArrayList<RefactoringScriptReference>(), executeAfter);
    myParts = ListSequence.fromListWithValues(new ArrayList<RefactoringPartImpl>(), parts);
  }
  public String getCaption() {
    return myCaption;
  }
  public RefactoringScriptReference getReference() {
    return myDescriptor;
  }
  public Iterable<RefactoringScriptReference> getExecuteAfter() {
    return myExecuteAfter;
  }
  @Override
  public void setSession(RefactoringSession s) {
    mySession = s;
  }
  @Override
  public void setTaskExecutor(_FunctionTypes._void_P1_E0<? super Runnable> runner) {
    myRunner = runner;
  }
  @Override
  public void setRefactoringProcessor(_FunctionTypes._void_P4_E0<? super RefactoringUI, ? super RefactoringParticipant.PersistentRefactoringParticipant, ? super Iterable<SNode>, ? super Map<SNode, SNode>> refactoringProcessor) {
    myRefactoringProcessor = refactoringProcessor;
  }
  public SNode execute(SModule module) {
    for (RefactoringPartImpl part : ListSequence.fromList(myParts)) {
      part.execute(module, mySession, myRunner, myRefactoringProcessor);
    }
    return null;
  }
}
