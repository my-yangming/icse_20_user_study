package jetbrains.mps.console.ideCommands.util;

/*Generated by MPS */

import jetbrains.mps.ide.messages.MessagesViewTool;
import jetbrains.mps.console.tool.ConsoleStream;
import jetbrains.mps.generator.ModelGenerationPlan;
import jetbrains.mps.generator.runtime.TemplateModule;
import java.util.Collection;
import jetbrains.mps.generator.runtime.TemplateMappingPriorityRule;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.generator.impl.plan.GenerationPlan;
import java.util.Arrays;
import java.util.List;
import jetbrains.mps.generator.runtime.TemplateMappingConfiguration;
import jetbrains.mps.util.Pair;
import jetbrains.mps.generator.impl.plan.GenerationPartitioningUtil;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import jetbrains.mps.generator.impl.plan.ConnectedComponentPartitioner;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.generator.impl.plan.Conflict;
import java.util.Set;

public class PartitioningHelper {
  private final MessagesViewTool messagesView;
  private final ConsoleStream console;
  private String delimiter = "=================================";

  public PartitioningHelper(MessagesViewTool viewTool, ConsoleStream console) {
    this.messagesView = viewTool;
    this.console = console;
  }

  public void show(ModelGenerationPlan plan) {
    // print all rules 
    messageViewDelimiter();
    for (TemplateModule generator : plan.getGenerators()) {
      Collection<TemplateMappingPriorityRule> rules = generator.getPriorities();
      for (TemplateMappingPriorityRule r : rules) {
        Message msg = new Message(MessageKind.INFORMATION, r.toString());
        msg.setHintObject(generator.getModuleReference());
        messagesView.add(msg);
      }
    }
    messageViewDelimiter();
    if (plan instanceof GenerationPlan) {
      GenerationPlan planImpl = (GenerationPlan) plan;
      if (planImpl.hasIgnoredPriorityRules()) {
        printPlanConflicts(planImpl.getIgnoredPriorityRules(), "Ignored mapping priority rules:");
      }
      if (planImpl.hasConflictingPriorityRules()) {
        printPlanConflicts(planImpl.getConflicts(), "Conflicting mapping priority rules encountered:");
      }
    }
    // show partitioning 
    console.addText("---------------------  mappings partitioning  -----------------------------------\n\n");
    int stepCount = 1;
    for (ModelGenerationPlan.Step step : plan.getSteps()) {
      console.addText(" [ " + stepCount++ + " ]\n");
      printStep(step, 0);
      console.addText("\n");
    }
    console.addText("---------------------------------------------------------------------------------\n");
  }

  private void printStep(ModelGenerationPlan.Step step, int indent) {
    char[] indentText = new char[indent * 2];
    Arrays.fill(indentText, ' ');
    String indentString = new String(indentText);
    if (step instanceof ModelGenerationPlan.Checkpoint) {

      console.addText(String.format("%s Checkpoint: %s\n", indentString, ((ModelGenerationPlan.Checkpoint) step).getName()));
    } else if (step instanceof ModelGenerationPlan.Transform) {
      List<TemplateMappingConfiguration> mappingSet = ((ModelGenerationPlan.Transform) step).getTransformations();
      List<Pair<String, TemplateMappingConfiguration>> strings = GenerationPartitioningUtil.toStrings(mappingSet);
      for (Pair<String, TemplateMappingConfiguration> string : strings) {
        SNode node = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x360b134fc0467d73L, "jetbrains.mps.console.ideCommands.structure.ClickableGenerator"));
        SPropertyOperations.assign(node, MetaAdapterFactory.getProperty(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x360b134fc0467d73L, 0x360b134fc0525d7fL, "moduleId"), PersistenceFacade.getInstance().asString(string.o2.getModel().getModule().getModuleReference().getModuleId()));
        SPropertyOperations.assign(node, MetaAdapterFactory.getProperty(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x2095ece53bb9f5b0L, 0x360b134fc047ce2aL, "text"), string.o1);
        console.addText(indentString);
        console.addText(" ");
        console.addNode(node);
        console.addText("\n");
      }
    } else if (step instanceof ModelGenerationPlan.Fork) {
      ModelGenerationPlan.Fork fork = (ModelGenerationPlan.Fork) step;
      console.addText(String.format("%s Fork:\n", indentString));
      for (ModelGenerationPlan.Step s : fork.getBranch()) {
        printStep(s, indent + 1);
        console.addText("\n");
      }
    } else {
      console.addText(String.format("%s Unknown step kind: %s\n", indentString, step.getClass()));
    }
  }

  public void printConnectedComponents(Iterable<SModel> models) {
    // other 
    List<SNode> roots = new ArrayList<SNode>();
    for (SModel md : models) {
      for (SNode root : md.getRootNodes()) {
        roots.add(root);
      }
    }
    ConnectedComponentPartitioner ccp = new ConnectedComponentPartitioner(roots);
    console.addText(ccp.toString());

    // viewTool.append("---------- conflicts ------------\n"); 
    //  
    // Map<String, String> existing = new HashMap<String, String>(); 
    // MPSModuleRepository repo = MPSModuleRepository.getInstance(); 
    // for(Generator g : repo.getAllGenerators()) { 
    //  List<SModel> templateModels = g.getOwnTemplateModels(); 
    //  for (SModel templateModel : templateModels) { 
    //    SModel m = templateModel; 
    //    for(SNode root : m.getRoots()) { 
    //      for(SNode node : root.getDescendants(new IsInstanceCondition(MappingLabelDeclaration.concept))){ 
    //        MappingLabelDeclaration label = (MappingLabelDeclaration) node.getAdapter(); 
    //        String name = label.getName(); 
    //        String descr = "model = " + m.toString() + ", root =" + root.toString(); 
    //        if(existing.containsKey(name)) { 
    //          viewTool.append("conflict: name = " + name + ", " + descr + ": with + " + existing.get(name) + "\n"); 
    //        } else { 
    //          existing.put(name, descr); 
    //        } 
    //      } 
    //    } 
    //  } 
    // } 
  }

  public void printLanguages(Collection<SLanguage> languagesInUse) {
    console.addText("Model directly uses next languages (including explicitly engaged, if any):\n");
    for (SLanguage l : languagesInUse) {
      console.addText("  ");
      console.addText(String.format("%s\n", l.getQualifiedName()));
    }
    consoleDelimiter();
  }

  public void printToConsole(String header, Collection<String> lines) {
    console.addText(header);
    console.addText("\n");
    for (String s : lines) {
      console.addText(s);
      console.addText("\n");
    }
    consoleDelimiter();
  }

  private void printPlanConflicts(List<Conflict> conflicts, String header) {
    messagesView.add(new Message(MessageKind.ERROR, PartitioningHelper.class, header));
    console.addText(header);
    console.addText("\n\n");
    for (Conflict c : conflicts) {
      Message msg = new Message(MessageKind.ERROR, PartitioningHelper.class, c.getText());
      msg.setHintObject(c.getOrigin());
      messagesView.add(msg);
      console.addText(String.format("%s\n", c.getText()));
      Set<TemplateMappingPriorityRule> rules = c.getRules();
      if (!(rules.isEmpty())) {
        if (rules.size() == 1) {
          console.addText(String.format("\tRule: %s\n", rules.iterator().next()));
        } else {
          console.addText("\tRules:\n");
          for (TemplateMappingPriorityRule r : rules) {
            console.addText(String.format("\t%s\n", r));
          }
        }
      }
    }
    consoleDelimiter();
    messageViewDelimiter();
  }

  private void consoleDelimiter() {
    console.addText(delimiter);
    console.addText("\n");
  }

  private void messageViewDelimiter() {
    messagesView.add(new Message(MessageKind.INFORMATION, delimiter));
  }
}
