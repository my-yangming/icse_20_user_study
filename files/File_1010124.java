package jetbrains.mps.ide.findusages.model;

/*Generated by MPS */

import jetbrains.mps.findUsages.UsagesList;
import jetbrains.mps.ide.findusages.findalgorithm.finders.SearchedObjects;
import java.util.List;
import java.util.Collections;
import java.util.ArrayList;
import java.util.Collection;
import org.jetbrains.annotations.NotNull;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.util.Set;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.LinkedHashSet;
import org.jetbrains.mps.openapi.model.SNode;

/**
 * must become immutable
 * 
 * the type parameter T does not make much sense since we allow usages with different kinds to be in the same
 * SearchResults container
 */
public class SearchResults<T> implements UsagesList {
  private final SearchedObjects<?> mySearchedObjects;
  private final List<SearchResult<T>> mySearchResults;

  public SearchResults() {
    mySearchedObjects = new SearchedObjects(Collections.emptySet());
    mySearchResults = new ArrayList<SearchResult<T>>();
  }

  public SearchResults(SearchedObjects<?> searchedObjects, List<SearchResult<T>> searchResults) {
    mySearchedObjects = searchedObjects;
    mySearchResults = searchResults;
  }

  public SearchResults(Collection<?> searchedObjects, List<SearchResult<T>> searchResults) {
    mySearchedObjects = new SearchedObjects(searchedObjects);
    mySearchResults = searchResults;
  }

  @NotNull
  public static <T> SearchResults<T> empty() {
    return new SearchResults();
  }

  @NotNull
  public static SearchResults union(@NotNull SearchResults one, @NotNull SearchResults another) {
    SearchedObjects searchedObjects1 = one.getSearchedObjects();
    SearchedObjects searchedObjects2 = another.getSearchedObjects();
    SearchedObjects searchedObjects = SearchedObjects.union(searchedObjects1, searchedObjects2);
    List<SearchResult> searchResults = Stream.<SearchResult>concat(((List<SearchResult>) one.getSearchResults2()).stream(), ((List<SearchResult>) another.getSearchResults2()).stream()).collect(Collectors.<SearchResult>toList());
    return new SearchResults(searchedObjects, searchResults);
  }

  @NotNull
  public SearchedObjects<?> getSearchedObjects() {
    return mySearchedObjects;
  }

  /**
   * @deprecated need to remove this since it exposes the internals too much.
   *             in my view the provided constructors of the class must be enough
   * use #getSearchedObjects instead
   */
  @Deprecated
  public Set<Object> getSearchedNodes() {
    // mySearchNodes lists elements we looked for; elements our results 'derived' from. They are not necessarily of the same 
    // kind as our results, hence we use <?>, not <T> (I don't feel there's reason introduce <E> as it 
    // (a) limits where we can look; (b) complicates the code 
    return (Set<Object>) mySearchedObjects.getElements0();
  }

  /**
   * 
   * @deprecated use #getSearchResults2
   */
  @Deprecated
  public List<SearchResult<T>> getSearchResults() {
    return mySearchResults;
  }

  public List<SearchResult<T>> getSearchResults2() {
    return Collections.unmodifiableList(mySearchResults);
  }

  public Set<T> getResultObjects() {
    Set<T> resultObjects = new HashSet<T>();
    for (SearchResult<T> searchResult : mySearchResults) {
      resultObjects.add(searchResult.getObject());
    }
    return resultObjects;
  }

  /**
   * 
   * @deprecated use #addSearchResult
   */
  @Deprecated
  public void add(@NotNull SearchResult<T> result) {
    mySearchResults.add(result);
  }

  /**
   * 
   * @deprecated use #addSearchResults
   */
  @Deprecated
  public void addAll(@NotNull SearchResults<T> results) {
    mySearchResults.addAll(results.mySearchResults);
  }

  @Override
  public Set<SModel> getAffectedModels() {
    LinkedHashSet<SModel> result = new LinkedHashSet<SModel>();
    for (SearchResult searchResult : mySearchResults) {
      Object resultObject = searchResult.getObject();
      if (resultObject instanceof SNode) {
        SModel model = ((SNode) resultObject).getModel();
        if (model != null) {
          result.add(model);
        }
      } else
      if (resultObject instanceof SModel) {
        result.add((SModel) resultObject);
      }
    }
    return result;
  }

  @NotNull
  public List<SearchResult<T>> getNotNullResults() {
    List<SearchResult<T>> alive = new ArrayList<SearchResult<T>>();
    for (SearchResult<T> result : mySearchResults) {
      if (result.getObject() != null) {
        alive.add(result);
      }
    }
    return alive;
  }

  @NotNull
  public SearchResults<T> removeDuplicates() {
    return new SearchResults<T>(getSearchedObjects(), (List<SearchResult<T>>) mySearchResults.stream().distinct().collect(Collectors.toList()));
  }

  @NotNull
  public SearchResults<T> addSearchedObjects(SearchedObjects<?> objectsToAdd) {
    SearchedObjects<?> searchedObjects = SearchedObjects.union((SearchedObjects) getSearchedObjects(), (SearchedObjects) objectsToAdd);
    return new SearchResults<T>(searchedObjects, getSearchResults2());
  }

  @NotNull
  public SearchResults<T> addSearchResult(@NotNull SearchResult<T> searchResult) {
    List<SearchResult<T>> results = new ArrayList<SearchResult<T>>(getSearchResults2());
    results.add(searchResult);
    return new SearchResults<T>(getSearchedObjects(), results);
  }

  @NotNull
  public SearchResults<T> addSearchResults(@NotNull SearchResults<T> searchResults) {
    return SearchResults.union(this, searchResults);
  }
}
