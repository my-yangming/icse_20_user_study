package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.Collections;
import jetbrains.mps.util.containers.EmptyIterable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import java.util.Objects;
import jetbrains.mps.util.Computable;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Map;

public abstract class MigrationScriptBase implements MigrationScript {
  private DataCollector myDC = new MigrationScriptBase.EmptyDataCollector();

  public String getCaption() {
    return "";
  }

  public void setDataCollector(DataCollector dataCollector) {
    myDC = dataCollector;
  }

  protected DataCollector getDataCollector() {
    return myDC;
  }

  public boolean isRerunnable() {
    return false;
  }

  @Override
  public MigrationScriptReference getReference() {
    return getDescriptor();
  }
  @Deprecated
  @ToRemove(version = 2017.2)
  public MigrationScriptReference getDescriptor() {
    return null;
  }
  public Iterable<Problem> check(SModule module) {
    return Collections.emptyList();
  }

  public Iterable<MigrationScriptReference> requiresData() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  public Iterable<MigrationScriptReference> executeAfter() {
    return new EmptyIterable<MigrationScriptReference>();
  }

  @Override
  public String toString() {
    return getCaption();
  }

  protected void adjustMigratedIds(SNode node, SNode migrated) {
    if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).contains(migrated))) {
      ((jetbrains.mps.smodel.SNode) migrated).setId(node.getNodeId());
    }
  }

  private interface SNodePlacePointer {
    boolean isNodeInPlace();
    void insertOrReplace(SNode newNode);
    void remove();
    class ChildPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SNode parent;
      private SContainmentLink link;
      private SNode nextSibling;
      /*package*/ ChildPointer(SNode node) {
        this.node = node;
        parent = node.getParent();
        link = node.getContainmentLink();
        nextSibling = node.getNextSibling();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == parent;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          parent.insertChildBefore(link, newNode, nextSibling);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          parent.removeChild(node);
        }
      }
    }
    class RootPointer implements MigrationScriptBase.SNodePlacePointer {
      private SNode node;
      private SModel model;
      /*package*/ RootPointer(SNode node) {
        this.node = node;
        model = node.getModel();
      }
      public boolean isNodeInPlace() {
        return node.getParent() == null && node.getModel() == model;
      }
      public void insertOrReplace(SNode newNode) {
        if (isNodeInPlace()) {
          SNodeUtil.replaceWithAnother(node, newNode);
        } else {
          model.addRootNode(newNode);
        }
      }
      public void remove() {
        if (!(isNodeInPlace())) {
          model.removeRootNode(node);
        }
      }
    }
  }
  private static MigrationScriptBase.SNodePlacePointer createSNodePlacePointer(SNode node) {
    if (node.getParent() != null) {
      return new MigrationScriptBase.SNodePlacePointer.ChildPointer(node);
    } else {
      return new MigrationScriptBase.SNodePlacePointer.RootPointer(node);
    }
  }

  public static SNode detachNodePatternVariable(SNode node) {
    return SNodeOperations.deleteNode(node);
  }
  public static List<SNode> detachListPatternVariable(List<SNode> nodes) {
    for (SNode node : ListSequence.fromList(nodes)) {
      SNodeOperations.deleteNode(node);
    }
    return nodes;
  }

  public boolean isInTransformPattern(SNode node) {
    if (!(SModuleOperations.isAspect(SNodeOperations.getModel(node), "migration"))) {
      return false;
    }
    SNode enclosingPattern = SNodeOperations.getNodeAncestor(node, MetaAdapterFactory.getConcept(0xd4615e3bd6714ba9L, 0xaf012b78369b0ba7L, 0x108a9cb4791L, "jetbrains.mps.lang.pattern.structure.PatternExpression"), false, false);
    return (enclosingPattern != null) && SNodeOperations.hasRole(enclosingPattern, MetaAdapterFactory.getContainmentLink(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x4e382b39b6529ec9L, 0x4e382b39b6529eeeL, "pattern"));
  }

  protected void markAnnotatedNodeForReview(SNode n, List<SNode> unknownAttrs) {
    unknownAttrs = ListSequence.fromList(unknownAttrs).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x2274019e61f0c2c8L, "jetbrains.mps.lang.core.structure.MigrationAnnotation_old")));
      }
    }).toListSequence();
    if (ListSequence.fromList(unknownAttrs).isEmpty()) {
      return;
    }

    SNode ann = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e06L, "jetbrains.mps.lang.core.structure.ReviewMigration"));
    SPropertyOperations.set(ann, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e13L, 0x78c7e79625a38e14L, "createdByScript"), this.getReference().serialize());
    SPropertyOperations.assign(ann, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e06L, 0x78c7e79625a38e07L, "reasonShort"), "unknown attributes");
    SPropertyOperations.assign(ann, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e06L, 0x78c7e79625a38e08L, "todo"), "This node should have been migrated, but has annotations not recognised by the migration. Please review this code and migrate manually if necessary. Unknown attribute: " + SNodeOperations.getConcept(ListSequence.fromList(unknownAttrs).first()).getQualifiedName());
    SPropertyOperations.assign(ann, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e06L, 0x78c7e79625a38e09L, "readableId"), getCaption());
    AttributeOperations.setAttribute(n, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x78c7e79625a38e06L, "jetbrains.mps.lang.core.structure.ReviewMigration")), ann);

    // we want this annotation to be shown as outermost one 
    SNode firstAnnot = ListSequence.fromList(AttributeOperations.getAttributeList(n, new IAttributeDescriptor.AllAttributes())).first();
    if ((firstAnnot != null) && !(Objects.equals(firstAnnot, ann))) {
      SNodeOperations.insertPrevSiblingChild(firstAnnot, ann);
    }
  }

  protected void applyTransormMigration(SNode origin, Computable<SNode> migration, _FunctionTypes._void_P2_E0<? super SNode, ? super SNode> postprocess) {
    MigrationScriptBase.SNodePlacePointer pointer = createSNodePlacePointer(origin);
    List<SNode> descendants = SNodeOperations.getNodeDescendants(origin, null, true, new SAbstractConcept[]{});

    SNode migrated = migration.compute();

    if (postprocess != null) {
      postprocess.invoke(origin, migrated);
    }

    if (migrated == null) {
      // origin should be removed 
      pointer.remove();
    } else {
      if (!(ListSequence.fromList(descendants).contains(migrated)) && migrated instanceof jetbrains.mps.smodel.SNode) {
        // returned value is new created node 
        if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(origin, null, false)).contains(migrated))) {
          // origin is not keeped 
          ((jetbrains.mps.smodel.SNode) migrated).setId(origin.getNodeId());
        }
      }
      pointer.insertOrReplace(migrated);
    }
  }

  private class EmptyDataCollector implements DataCollector {
    public EmptyDataCollector() {
    }
    public Map<SModule, SNode> collectData(SModule myModule, MigrationScriptReference scriptReference) {
      return Collections.<SModule,SNode>emptyMap();
    }
  }
}
