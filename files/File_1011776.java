package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import com.intellij.openapi.ui.FrameWrapper;
import com.intellij.openapi.actionSystem.DataProvider;
import jetbrains.mps.project.MPSProject;
import com.intellij.diff.DiffRequestPanel;
import org.jetbrains.mps.openapi.model.SNodeId;
import com.intellij.openapi.vfs.VirtualFile;
import java.util.List;
import com.intellij.openapi.vcs.history.VcsFileRevision;
import java.util.ArrayList;
import com.intellij.openapi.vcs.history.CurrentRevision;
import com.intellij.util.ui.ListTableModel;
import com.intellij.ui.table.TableView;
import com.intellij.openapi.ui.Splitter;
import javax.swing.JLabel;
import com.intellij.ui.components.JBLabel;
import com.intellij.util.ui.AnimatedIcon;
import com.intellij.util.ui.AsyncProcessIcon;
import javax.swing.JEditorPane;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.openapi.vcs.history.VcsHistoryProvider;
import com.intellij.openapi.vcs.history.VcsHistorySession;
import com.intellij.util.ObjectUtils;
import com.intellij.util.ui.UIUtil;
import com.intellij.util.ui.JBDimension;
import com.intellij.ui.BrowserHyperlinkListener;
import javax.swing.JRootPane;
import javax.swing.RootPaneContainer;
import com.intellij.openapi.vcs.history.VcsDependentHistoryComponents;
import com.intellij.util.ui.ColumnInfo;
import com.intellij.openapi.vcs.history.FileHistoryPanelImpl;
import com.intellij.util.ArrayUtil;
import com.intellij.openapi.vcs.changes.issueLinks.TableLinkMouseListener;
import com.intellij.openapi.vcs.VcsBundle;
import com.intellij.diff.DiffManager;
import com.intellij.openapi.vcs.history.VcsRevisionNumber;
import org.jetbrains.annotations.NotNull;
import com.intellij.ui.JBSplitter;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.ListSelectionEvent;
import com.intellij.openapi.vcs.changes.issueLinks.IssueLinkHtmlRenderer;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.vcs.annotate.ShowAllAffectedGenericAction;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.vcs.VcsActions;
import com.intellij.ui.PopupHandler;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.actionSystem.AnAction;
import java.util.Collection;
import com.intellij.util.ui.update.Update;
import com.intellij.openapi.progress.util.BackgroundTaskUtil;
import com.intellij.diff.requests.NoDiffRequest;
import com.intellij.diff.util.IntPair;
import com.intellij.diff.contents.DiffContent;
import com.intellij.diff.requests.SimpleDiffRequest;
import jetbrains.mps.vcs.platform.integration.ModelDiffViewer;
import com.intellij.diff.requests.LoadingDiffRequest;
import com.intellij.diff.requests.MessageDiffRequest;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import com.intellij.ui.ScrollPaneFactory;
import java.awt.FlowLayout;
import org.jetbrains.annotations.NonNls;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import com.intellij.openapi.vcs.VcsDataKeys;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.openapi.util.Conditions;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vcspersistence.VCSPersistenceUtil;
import jetbrains.mps.project.MPSExtentions;
import com.intellij.diff.contents.EmptyContent;
import jetbrains.mps.vcs.platform.integration.ModelDiffContent;
import com.intellij.openapi.util.Disposer;

/**
 * Most of this class copied from IDEA's VcsSelectionHistoryDialog
 */
public final class RootHistoryDialog extends FrameWrapper implements DataProvider {
  private final MPSProject myMPSProject;
  private final DiffRequestPanel myDiffPanel;
  private SNodeId myRoot;
  private final VirtualFile myActualFile;
  private final String myHelpId;

  private static final float DIFF_SPLITTER_PROPORTION = 0.5f;
  private static final float COMMENTS_SPLITTER_PROPORTION = 0.8f;
  private static final String DIFF_SPLITTER_PROPORTION_KEY = "file.history.selection.diff.splitter.proportion";
  private static final String COMMENTS_SPLITTER_PROPORTION_KEY = "file.history.selection.comments.splitter.proportion";

  private final List<VcsFileRevision> myRevisions = new ArrayList<VcsFileRevision>();
  private final CurrentRevision myLocalRevision;

  private final ListTableModel<VcsFileRevision> myListModel;
  private final TableView<VcsFileRevision> myList;
  private final Splitter mySplitter;
  private final JLabel myStatusLabel = new JBLabel();
  private final AnimatedIcon myStatusSpinner = new AsyncProcessIcon(getClass().getSimpleName());
  private final JEditorPane myComments;
  private final MergingUpdateQueue myUpdateQueue;

  private RootHistoryModel myHistoryExtractor;

  private boolean myIsDuringUpdate = false;


  public RootHistoryDialog(MPSProject project, VirtualFile actualFile, VcsHistoryProvider vcsHistoryProvider, VcsHistorySession session) {
    super(project.getProject(), "MPS.RootHistoryDialog", false);
    // no idea why VcsSelectionHistoryDialog uses isDialog == false 
    myMPSProject = project;
    myActualFile = actualFile;
    // copied from VcsSelectionHistoryDialog 
    myHelpId = ObjectUtils.notNull(vcsHistoryProvider.getHelpId(), "reference.dialogs.vcs.selection.history");
    myComments = new JEditorPane(UIUtil.HTML_MIME, "");
    myComments.setPreferredSize(new JBDimension(150, 100));
    myComments.setEditable(false);
    myComments.addHyperlinkListener(BrowserHyperlinkListener.INSTANCE);
    JRootPane rootPane = ((RootPaneContainer) getFrame()).getRootPane();
    final VcsDependentHistoryComponents components = vcsHistoryProvider.getUICustomization(session, rootPane);
    ColumnInfo[] defaultColumns = new ColumnInfo[]{new FileHistoryPanelImpl.RevisionColumnInfo(null), new FileHistoryPanelImpl.DateColumnInfo(), new FileHistoryPanelImpl.AuthorColumnInfo(), new FileHistoryPanelImpl.MessageColumnInfo(project.getProject())};
    ColumnInfo[] additionalColumns = ObjectUtils.notNull(components.getColumns(), ColumnInfo.EMPTY_ARRAY);
    myListModel = new ListTableModel(ArrayUtil.mergeArrays(defaultColumns, additionalColumns));
    myListModel.setSortable(false);
    myList = new TableView(myListModel);
    new TableLinkMouseListener().installOn(myList);
    myList.getEmptyText().setText(VcsBundle.message("history.empty"));

    myDiffPanel = DiffManager.getInstance().createRequestPanel(project.getProject(), this, getFrame());
    myUpdateQueue = new MergingUpdateQueue(getClass().getSimpleName(), 300, true, myList, this);


    myLocalRevision = new CurrentRevision(actualFile, new VcsRevisionNumber() {
      @Override
      public int compareTo(VcsRevisionNumber p0) {
        return 0;
      }

      @NotNull
      @Override
      public String asString() {
        return "Local Changes";
      }
    });
    myRevisions.add(myLocalRevision);
    myRevisions.addAll(session.getRevisionList());

    mySplitter = new JBSplitter(true, DIFF_SPLITTER_PROPORTION_KEY, DIFF_SPLITTER_PROPORTION);
    mySplitter.setFirstComponent(myDiffPanel.getComponent());
    mySplitter.setSecondComponent(createBottomPanel(components.getDetailsComponent()));

    final ListSelectionListener selectionListener = new ListSelectionListener() {
      @Override
      public void valueChanged(ListSelectionEvent e) {
        final VcsFileRevision revision;
        if (myList.getSelectedRowCount() == 1 && !(myList.isEmpty())) {
          revision = myList.getItems().get(myList.getSelectedRow());
          String message = IssueLinkHtmlRenderer.formatTextIntoHtml(myMPSProject.getProject(), revision.getCommitMessage());
          myComments.setText(message);
          myComments.setCaretPosition(0);
        } else {
          revision = null;
          myComments.setText("");
        }
        if (components.getRevisionListener() != null) {
          components.getRevisionListener().consume(revision);
        }
        updateDiff();
      }
    };
    myList.getSelectionModel().addListSelectionListener(selectionListener);
    final DefaultActionGroup popupActions = new DefaultActionGroup();
    popupActions.add(ShowAllAffectedGenericAction.getInstance());
    popupActions.add(ActionManager.getInstance().getAction(VcsActions.ACTION_COPY_REVISION_NUMBER));
    PopupHandler.installPopupHandler(myList, popupActions, ActionPlaces.UPDATE_POPUP, ActionManager.getInstance());
    for (AnAction action : popupActions.getChildren(null)) {
      action.registerCustomShortcutSet(action.getShortcutSet(), mySplitter);
    }

    setTitle(myActualFile.getName());
    setComponent(mySplitter);
    setPreferredFocusedComponent(myList);
    closeOnEsc();

  }

  public void show(Collection<SNodeId> selection) {
    // for the moment, I support single node scenario. Moreover, root node, as DiffModelViewer (along with ChangeSet) is incapable to show changes for anything but root 
    myRoot = selection.iterator().next();
    myHistoryExtractor = new RootHistoryModel(myRevisions, myRoot, new Runnable() {
      public void run() {
        myUpdateQueue.queue(new Update(this) {
          @Override
          public void run() {
            updateStatusLine();
            updateRevisionList();
          }
        });
      }
    });
    BackgroundTaskUtil.executeOnPooledThread(this, myHistoryExtractor);
    updateRevisionList();

    show();
  }

  /*package*/ void updateStatusLine() {
    if (myHistoryExtractor.isLoading()) {
      myStatusLabel.setText(String.format("Analyzing revision %d/%d ...", myHistoryExtractor.processedRevisions(), myHistoryExtractor.totalRevisions()));
      myStatusSpinner.resume();
      myStatusSpinner.setVisible(true);
    } else {
      myStatusLabel.setText("");
      myStatusSpinner.suspend();
      myStatusSpinner.setVisible(false);
    }
  }

  /*package*/ void updateRevisionList() {
    try {
      if (myIsDuringUpdate) {
        return;
      }
      myIsDuringUpdate = true;

      myListModel.setItems(myHistoryExtractor.revisions());

    } finally {
      myIsDuringUpdate = false;
    }
  }

  private void updateDiff() {
    if (isDisposed() || myIsDuringUpdate) {
      return;
    }
    if (myList.getSelectedRowCount() == 0) {
      myDiffPanel.setRequest(NoDiffRequest.INSTANCE);
      return;
    }
    int count = myRevisions.size();
    IntPair range = getSelectedRevisionsRange();
    int revIndex1 = range.val2;
    int revIndex2 = range.val1;
    if (revIndex1 == count && revIndex2 == count) {
      myDiffPanel.setRequest(NoDiffRequest.INSTANCE);
      return;
    }

    DiffContent content1 = createDiffContent(revIndex1);
    DiffContent content2 = createDiffContent(revIndex2);
    String title1 = myRevisions.get(revIndex1).getRevisionNumber().asString();
    String title2 = myRevisions.get(revIndex2).getRevisionNumber().asString();
    if (content1 != null && content2 != null) {
      SimpleDiffRequest rq = new SimpleDiffRequest(null, content1, content2, title1, title2);
      ModelDiffViewer.DIFF_SHOW_ROOTID.set(rq, myRoot);
      ModelDiffViewer.DIFF_SHOW_TREE.set(rq, false);
      myDiffPanel.setRequest(rq, new IntPair(revIndex1, revIndex2));
      return;
    }

    if (myHistoryExtractor.isLoading()) {
      myDiffPanel.setRequest(new LoadingDiffRequest());
    } else {
      // FIXME throw an exception from createDiffContent, catch it here and present to user through MessageDiffRequest (there's no DiffContent that could do that instead) 
      myDiffPanel.setRequest(new MessageDiffRequest("Error", "Failed to build diff for selected revisions"));
    }
  }

  private JComponent createBottomPanel(final JComponent addComp) {
    JBSplitter splitter = new JBSplitter(true, COMMENTS_SPLITTER_PROPORTION_KEY, COMMENTS_SPLITTER_PROPORTION);
    splitter.setDividerWidth(4);

    JPanel tablePanel = new JPanel(new BorderLayout());
    tablePanel.add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);

    JPanel statusPanel = new JPanel(new FlowLayout());
    statusPanel.add(myStatusSpinner);
    statusPanel.add(myStatusLabel);

    JPanel separatorPanel = new JPanel(new BorderLayout());
    separatorPanel.add(statusPanel, BorderLayout.EAST);
    tablePanel.add(separatorPanel, BorderLayout.NORTH);

    splitter.setFirstComponent(tablePanel);
    splitter.setSecondComponent(createComments(addComp));
    return splitter;
  }

  private JComponent createComments(final JComponent addComp) {
    JPanel panel = new JPanel(new BorderLayout(4, 4));
    panel.add(new JLabel("Commit Message:"), BorderLayout.NORTH);
    panel.add(ScrollPaneFactory.createScrollPane(myComments), BorderLayout.CENTER);
    final Splitter splitter = new Splitter(false);
    splitter.setFirstComponent(panel);
    splitter.setSecondComponent(addComp);
    return splitter;
  }

  @Override
  public Object getData(@NotNull @NonNls String dataId) {
    if (CommonDataKeys.PROJECT.is(dataId)) {
      return myMPSProject.getProject();
    } else if (MPSCommonDataKeys.MPS_PROJECT.is(dataId)) {
      return myMPSProject;
    } else
    if (VcsDataKeys.VCS_VIRTUAL_FILE.is(dataId)) {
      return myActualFile;
    } else
    if (VcsDataKeys.VCS_FILE_REVISION.is(dataId)) {
      VcsFileRevision selectedObject = myList.getSelectedObject();
      return (selectedObject instanceof CurrentRevision ? null : selectedObject);
    } else
    if (VcsDataKeys.VCS_FILE_REVISIONS.is(dataId)) {
      List<VcsFileRevision> revisions = ContainerUtil.filter(myList.getSelectedObjects(), Conditions.notEqualTo(myLocalRevision));
      return revisions.toArray(new VcsFileRevision[0]);
    } else
    if (PlatformDataKeys.HELP_ID.is(dataId)) {
      return myHelpId;
    }
    return null;
  }

  @NotNull
  private IntPair getSelectedRevisionsRange() {
    List<VcsFileRevision> selection = myList.getSelectedObjects();
    if (selection.isEmpty()) {
      return new IntPair(0, 0);
    }
    int startIndex = myRevisions.indexOf(ContainerUtil.getFirstItem(selection));
    int endIndex = myRevisions.indexOf(ContainerUtil.getLastItem(selection));
    // [artem] this +1 looks odd, provided it's an index in myRevisions (complete set), not in myList.getItems (revisions with changes) 
    // however, this makes sense as we'd like to see diff of changed revision not to the prev change but to the prev state (which could be change state, but could be 'same'/unchanged state as well). 
    return new IntPair(startIndex, endIndex + 1);
  }

  @Nullable
  private DiffContent createDiffContent(int revIndex) {
    VcsFileRevision rev = myRevisions.get(revIndex);
    SModel loaded;
    try {
      loaded = VCSPersistenceUtil.loadModel(rev.loadContent(), MPSExtentions.MODEL);
    } catch (Exception ex) {
      return null;
    }
    // ModelDiffViewer doesn't tolerate reusable detached models, it registers and disposes such models solely on its own discretion 
    return (loaded == null ? new EmptyContent() : new ModelDiffContent(loaded));
  }
  @Override
  public void dispose() {
    Disposer.dispose(myDiffPanel);
    super.dispose();
  }
}
