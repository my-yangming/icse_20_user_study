package jetbrains.mps.baseLanguage.execution.api;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.io.File;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.execution.api.commands.CommandPart;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.execution.api.commands.ListCommandPart;
import jetbrains.mps.execution.api.commands.ProcessHandlerBuilder;
import jetbrains.mps.execution.api.commands.KeyValueCommandPart;
import java.io.IOException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.debug.api.IDebugger;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.apache.log4j.Level;
import jetbrains.mps.textgen.trace.DebugInfo;
import jetbrains.mps.textgen.trace.TraceInfo;
import jetbrains.mps.textgen.trace.UnitPositionInfo;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.lang.traceable.behavior.TraceableConcept__BehaviorDescriptor;
import jetbrains.mps.textgen.trace.TraceablePositionInfo;
import java.util.Objects;
import java.util.Set;
import jetbrains.mps.project.facets.JavaModuleOperations;
import jetbrains.mps.reloading.CommonPaths;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.util.SystemInfo;
import com.intellij.util.SystemProperties;
import java.util.LinkedList;
import jetbrains.mps.debug.api.run.IDebuggerConfiguration;
import jetbrains.mps.debug.api.IDebuggerSettings;
import jetbrains.mps.debugger.java.api.settings.LocalConnectionSettings;
import jetbrains.mps.debug.api.Debuggers;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.smodel.SModelUtil_new;
import jetbrains.mps.smodel.SReference;

public class Java_Command {
  private static final Logger LOG = LogManager.getLogger(Java_Command.class);
  private File myWorkingDirectory_File = new File(".");
  private String myJrePath_String = Java_Command.getJdkHome();
  private String myProgramParameter_String;
  private String myVirtualMachineParameter_String;
  private List<String> myClassPath_ListString = ListSequence.fromList(new ArrayList<String>());
  private String myDebuggerSettings_String;
  private CommandPart myVirtualMachineParameter_ProcessBuilderCommandPart;
  public Java_Command() {
  }
  public Java_Command setWorkingDirectory_File(File workingDirectory) {
    if (workingDirectory != null) {
      myWorkingDirectory_File = workingDirectory;
    }
    return this;
  }
  public Java_Command setJrePath_String(String jrePath) {
    if (jrePath != null) {
      myJrePath_String = jrePath;
    }
    return this;
  }
  public Java_Command setProgramParameter_String(String programParameter) {
    if (programParameter != null) {
      myProgramParameter_String = programParameter;
    }
    return this;
  }
  public Java_Command setVirtualMachineParameter_String(String virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_String = virtualMachineParameter;
    }
    return this;
  }
  public Java_Command setClassPath_ListString(List<String> classPath) {
    if (classPath != null) {
      myClassPath_ListString = classPath;
    }
    return this;
  }
  public Java_Command setDebuggerSettings_String(String debuggerSettings) {
    if (debuggerSettings != null) {
      myDebuggerSettings_String = debuggerSettings;
    }
    return this;
  }
  public Java_Command setVirtualMachineParameter_ProcessBuilderCommandPart(CommandPart virtualMachineParameter) {
    if (virtualMachineParameter != null) {
      myVirtualMachineParameter_ProcessBuilderCommandPart = virtualMachineParameter;
    }
    return this;
  }

  public ProcessHandler createProcess(String className) throws ExecutionException {
    return new Java_Command().setWorkingDirectory_File(myWorkingDirectory_File).setJrePath_String(myJrePath_String).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(className, ListSequence.fromList(myClassPath_ListString).select(new ISelector<String, File>() {
      public File select(String it) {
        if (it.startsWith("\"") && it.endsWith("\"")) {
          return new File(it.substring(1, it.length() - 2));
        }
        return new File(it);
      }
    }).toListSequence());
  }
  public ProcessHandler createProcess(String className, List<File> classPath) throws ExecutionException {
    return new Java_Command().setWorkingDirectory_File(myWorkingDirectory_File).setJrePath_String(myJrePath_String).setVirtualMachineParameter_ProcessBuilderCommandPart(new ListCommandPart(ListSequence.fromListAndArray(new ArrayList(), myVirtualMachineParameter_String))).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(new ListCommandPart(ListSequence.fromListAndArray(new ArrayList(), myProgramParameter_String)), className, classPath);
  }
  public ProcessHandler createProcess(CommandPart programParameter, String className, List<File> classPath) throws ExecutionException {
    if ((className == null || className.length() == 0)) {
      throw new ExecutionException("Classname is empty");
    }
    File java = Java_Command.getJavaCommand(myJrePath_String);
    // FIXME need better logic to decide when to use java -jar, and when directly java -classpath 
    // Now I just throw in some magic number I consider too big to get tired of looking at long CP 
    // XXX Besides, I'd like to test this, therefore would like to see this branch to trigger often (MPS JUnit 
    // tests shall get into it, I believe). Earlier approach relied on dedicated ClassRunner, capable of reading 
    // classpath and arguments from serialized form in temp files, I don't think we can ever get to the limit 
    // with program arguments (and even if we do, e.g. enumerating all test methods from JUnit command, we can still 
    // address huge argument list with -f or piping input from file (i.e. runner would need to support arguments other than 
    // String[] args in main())) 
    if (ListSequence.fromList(classPath).count() > 20) {
      // next is to deal with very long cp 
      try {
        JarManifestBuilder jmb = new JarManifestBuilder();
        File jar = jmb.withMainClass(className).withFilesClassPath(classPath).toTempFile();
        return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter_ProcessBuilderCommandPart).append(myDebuggerSettings_String).append(new KeyValueCommandPart("-" + "jar", jar.getAbsolutePath())).append(programParameter).build(myWorkingDirectory_File);
      } catch (IOException e) {
        throw new ExecutionException("Could not create temporary file for program parameters and class path.", e);
      }
    } else {
      CommandPart classPathPart = new KeyValueCommandPart("-" + "classpath", new ListCommandPart(classPath, File.pathSeparator));
      return new ProcessHandlerBuilder().append(java).append(myVirtualMachineParameter_ProcessBuilderCommandPart).append(myDebuggerSettings_String).append(classPathPart).append(className).append(programParameter).build(myWorkingDirectory_File);
    }
  }
  public ProcessHandler createProcess(final SNodeReference nodePointer, final SRepository repository) throws ExecutionException {
    final Wrappers._T<SModule> module = new Wrappers._T<SModule>(null);
    final Wrappers._T<String> errorText = new Wrappers._T<String>(null);
    final Wrappers._T<List<String>> cp = new Wrappers._T<List<String>>();
    final Wrappers._T<String> cn = new Wrappers._T<String>();
    repository.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        SNode resolved = check_yvpt_a0a0a4a0d(nodePointer, repository);
        module.value = check_yvpt_a0b0a4a0d(check_yvpt_a0a1a0e0a3(resolved));
        if (module.value == null) {
          errorText.value = "Can't find module for node " + nodePointer;
        } else {
          cp.value = Java_Command.getClasspath(Sequence.<SModule>singleton(module.value));
          cn.value = Java_Command.getClassName(resolved);
        }
      }
    });

    if (errorText.value != null) {
      throw new ExecutionException(errorText.value);
    }

    return new Java_Command().setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setClassPath_ListString(cp.value).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(cn.value);
  }
  public ProcessHandler createProcess(JavaRunParameters runParameters, SNodeReference nodePointer, SRepository repository) throws ExecutionException {
    return new Java_Command().setJrePath_String(check_yvpt_a0a0a0e(runParameters)).setProgramParameter_String(check_yvpt_a3a0a0e(runParameters)).setVirtualMachineParameter_String(check_yvpt_a4a0a0e(runParameters)).setWorkingDirectory_File((isEmptyString(check_yvpt_a0a5a0a0e(runParameters)) ? null : new File(check_yvpt_a0a0f0a0a4(runParameters)))).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(nodePointer, repository);
  }

  public static IDebugger getDebugger() {
    return getDebuggerConfiguration().getDebugger();
  }

  public static boolean isUnitNode(SNode node) {
    return isNotEmptyString(Java_Command.getClassName(node));
  }
  private static String getClassName(SNode node) {
    SModel model = SNodeOperations.getModel(node);
    SNode module = SModelOperations.getModuleStub(SNodeOperations.getModel(node));
    if (model == null) {
      return null;
    }
    if (!(SPropertyOperations.getBoolean(module, MetaAdapterFactory.getProperty(0x86ef829012bb4ca7L, 0x947f093788f263a9L, 0x5869770da61dfe1eL, 0x5869770da61dfe24L, "compileInMPS")))) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("The hosting module's " + module + " classes are not managed by MPS");
      }
    }
    DebugInfo debugInfo = new TraceInfo().getDebugInfo(model);
    if (debugInfo == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("No trace.info found for model " + model + ". Check that model is generated.");
      }
      return null;
    } else {
      List<UnitPositionInfo> unitsForNode = debugInfo.getUnitsForNode(node);
      if (unitsForNode.isEmpty()) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("No unitName found for " + node + " in trace.info. Check that model is generated.");
        }
        return null;
      } else if (unitsForNode.size() == 1) {
        return unitsForNode.get(0).getUnitName();
      } else {
        // if there's more than 1 unit, find one holding position that matches main method 
        final SConcept staticMethodConcept = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration");
        final String mainMethodTraceableProperty = TraceableConcept__BehaviorDescriptor.getTraceableProperty_id4pl5GY7LKmH.invoke(_quotation_createNode_yvpt_a0a2a0b0a5a1());
        for (TraceablePositionInfo position : debugInfo.getRootInfo(SNodeOperations.getContainingRoot(node)).getPositions()) {
          if (Objects.equals(position.getConcept(), staticMethodConcept) && (Objects.equals(position.getPropertyString(), mainMethodTraceableProperty))) {
            for (UnitPositionInfo upi : unitsForNode) {
              if (upi.contains(position.getFileName(), position.getStartLine())) {
                return upi.getUnitName();
              }
            }
          }
        }
        return null;
      }
    }
  }
  private static int getMaxCommandLine() {
    // FIXME KEPT THIS METHOD FOR FUTURE CONSIDERATION, see classPath comment above regarding cmdline length 
    // the command line limit on win is 32767 characters 
    // (see http://blogs.msdn.com/b/oldnewthing/archive/2003/12/10/56028.aspx) 
    // we set the limit to 16384 (half as many) just in case 
    return 16384;
  }
  public static List<String> getClasspath(Iterable<SModule> modules) {
    Set<String> classpath = JavaModuleOperations.collectExecuteClasspath(Sequence.fromIterable(modules).toListSequence().toGenericArray(SModule.class));
    // Here used to be module/JDK/.getAdditionalJavaStubPaths, introduced in 6f53b9c0 with no explanation, 
    // which replaced CommonPaths.getJDKPath() introduced with no explanation either in b4a00256. 
    // As long as getAdditionalJavaStubPaths() are populated from CommonPaths.getJDKPath (see Solution) 
    // I see no reason to go though global module to retrieve these. To be honest, I don't quite get the need 
    // to remove java paths at all. 
    classpath.removeAll(CommonPaths.getJDKPath());
    return new ArrayList<String>(classpath);
  }
  public static File getJavaCommand(@Nullable String javaHome) throws ExecutionException {
    if ((javaHome == null || javaHome.length() == 0) || !(new File(javaHome).exists())) {
      javaHome = Java_Command.getJdkHome();
    }
    if ((javaHome == null || javaHome.length() == 0)) {
      throw new ExecutionException("Could not find valid java home.");
    }
    return new File(Java_Command.getJavaCommandPath(javaHome));
  }
  public static String getJavaCommandPath(String javaHome) {
    String result = javaHome + File.separator + "bin" + File.separator;
    String java = "java";
    if (SystemInfo.isMac) {
      result += java;
    } else
    if (SystemInfo.isWindows) {
      result += java + ".exe";
    } else {
      result += java;
    }
    return result;
  }
  public static List<String> getJavaHomes() {
    String systemJavaHome = SystemProperties.getJavaHome();
    List<String> homes = ListSequence.fromList(new LinkedList<String>());
    String systemJdkHome = systemJavaHome.substring(0, systemJavaHome.length() - "/jre".length());
    if (systemJavaHome.endsWith("jre") && new File(systemJdkHome + File.separator + "bin").exists()) {
      ListSequence.fromList(homes).addElement(systemJdkHome);
    }
    if (isNotEmptyString(System.getenv("JAVA_HOME"))) {
      ListSequence.fromList(homes).addElement(System.getenv("JAVA_HOME"));
    }
    ListSequence.fromList(homes).addElement(systemJavaHome);
    return homes;
  }
  public static String getJdkHome() {
    List<String> homes = Java_Command.getJavaHomes();
    for (String javaHome : homes) {
      if (new File(Java_Command.getJavaCommandPath(javaHome)).exists()) {
        return javaHome;
      }
    }
    return null;
  }
  public static String protect(String result) {
    if (result.contains(" ")) {
      return "\"" + result + "\"";
    }
    return result;
  }

  public static IDebuggerConfiguration getDebuggerConfiguration() {
    return new IDebuggerConfiguration() {
      @Nullable
      public IDebuggerSettings createDebuggerSettings() {
        return new LocalConnectionSettings(true);
      }
      public IDebugger getDebugger() {
        return Debuggers.getInstance().getDebuggerByName("Java");
      }
    };
  }
  private static SNode check_yvpt_a0a0a4a0d(SNodeReference checkedDotOperand, SRepository repository) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.resolve(repository);
    }
    return null;
  }
  private static SModule check_yvpt_a0b0a4a0d(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
  private static SModel check_yvpt_a0a1a0e0a3(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModel();
    }
    return null;
  }
  private static String check_yvpt_a0a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getAlternativeJre();
    }
    return null;
  }
  private static String check_yvpt_a3a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.programParameters();
    }
    return null;
  }
  private static String check_yvpt_a4a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.vmOptions();
    }
    return null;
  }
  private static String check_yvpt_a0a0f0a0a4(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }
  private static String check_yvpt_a0a5a0a0e(JavaRunParameters checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.workingDirectory();
    }
    return null;
  }
  private static SNode _quotation_createNode_yvpt_a0a2a0b0a5a1() {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode quotedNode_1 = null;
    SNode quotedNode_2 = null;
    SNode quotedNode_3 = null;
    SNode quotedNode_4 = null;
    SNode quotedNode_5 = null;
    SNode quotedNode_6 = null;
    SNode quotedNode_7 = null;
    quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0xfbbebabf0aL, "StaticMethodDeclaration"), null, null, false);
    quotedNode_1.setProperty(MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "main");
    quotedNode_2 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0xf8cc6bf96dL, "VoidType"), null, null, false);
    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, "returnType"), quotedNode_2);
    quotedNode_3 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0x10af9581ff1L, "PublicVisibility"), null, null, false);
    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112670d273fL, 0x112670d886aL, "visibility"), quotedNode_3);
    quotedNode_4 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0xf8cc56b200L, "StatementList"), null, null, false);
    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1ffL, "body"), quotedNode_4);
    quotedNode_5 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0xf8c77f1e94L, "ParameterDeclaration"), null, null, false);
    quotedNode_5.setProperty(MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"), "args");
    quotedNode_6 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0xf940d819f7L, "ArrayType"), null, null, false);
    quotedNode_7 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, "jetbrains.mps.baseLanguage"), 0x101de48bf9eL, "ClassifierType"), null, null, false);
    quotedNode_7.setReference(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), SReference.create(MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), quotedNode_7, facade.createModelReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065/java:java.lang(JDK/)"), facade.createNodeId("~String")));
    quotedNode_6.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, 0xf940d819f8L, "componentType"), quotedNode_7);
    quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type"), quotedNode_6);
    quotedNode_1.addChild(MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter"), quotedNode_5);
    return quotedNode_1;
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
  private static boolean isNotEmptyString(String str) {
    return str != null && str.length() > 0;
  }
}
