package jetbrains.mps.ide.depanalyzer;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.DevkitDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Set;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class DependencyUtil {
  private boolean myNeedRuntime;
  private final SRepository myRepo;
  /*package*/ DependencyUtil(SRepository repo) {
    myRepo = repo;
  }
  public DependencyUtil trackRuntime(boolean needRuntime) {
    this.myNeedRuntime = needRuntime;
    return this;
  }

  /**
   * Build set of dependencies for the given module, grouped under a fake root container
   */
  public DepLink build(SModule module) {
    DepLink rv = new DepLink(module.getModuleReference(), DependencyUtil.Role.None, null);
    List<DepLink> queue = ListSequence.fromList(new LinkedList<DepLink>());
    ListSequence.fromList(queue).addElement(rv);
    Map<Dependency, DepLink> visited = MapSequence.fromMap(new HashMap<Dependency, DepLink>());
    while (ListSequence.fromList(queue).isNotEmpty()) {
      DepLink e = ListSequence.fromList(queue).removeElementAt(0);
      List<DepLink> dependencies = dependencies(e.role, e.module);
      for (DepLink d : ListSequence.fromList(dependencies)) {
        d.myParent = e;
        ListSequence.fromList(e.children()).addElement(d);
        Dependency key = d.getRoleModuleKey();
        if (MapSequence.fromMap(visited).containsKey(key)) {
          d.setReused(MapSequence.fromMap(visited).get(key));
        } else {
          MapSequence.fromMap(visited).put(key, d);
          ListSequence.fromList(queue).addElement(d);
        }
      }
    }
    return rv;
  }
  private List<DepLink> dependencies(DependencyUtil.Role role, SModuleReference moduleRef) {
    List<DepLink> result = ListSequence.fromList(new ArrayList<DepLink>());
    SModule module = moduleRef.resolve(myRepo);
    if (module == null) {
      return result;
    }
    switch (role) {
      case OwnedGenerator:
      case None:
        // first step 
        addUsedLanguagesAndDevkitsOf(module, result, true);
        for (SDependency dep : module.getDeclaredDependencies()) {
          if (dep.getScope() == SDependencyScope.DESIGN && !(myNeedRuntime)) {
            // design-time dependencies are of now value during execution 
            continue;
          }
          ListSequence.fromList(result).addElement(regularDependencyPresentation(dep));
        }
        if (module instanceof Language) {
          // generators and generators dependencies are now also added to language dependencies (MPS-15883) 
          for (Generator g : ((Language) module).getGenerators()) {
            ListSequence.fromList(result).addElement(new DepLink(g.getModuleReference(), DependencyUtil.Role.OwnedGenerator, DependencyUtil.LinkType.Generator));
          }
        }
        if (module instanceof Generator) {
          SLanguage srcLang = ((Generator) module).sourceLanguage();
          ListSequence.fromList(result).addElement(new DepLink(srcLang.getSourceModuleReference(), DependencyUtil.Role.SourceLanguage, DependencyUtil.LinkType.GeneratorLanguage));
        }
        break;

      case UsedDevkit:
        // explicit use of devkit 
        // fall-through 
      case DependencyDevkit:
        if (!(module instanceof AbstractModule)) {
          break;
        }
        DevkitDescriptor devkit = as_he47wm_a0a1a3d0g(((AbstractModule) module).getModuleDescriptor(), DevkitDescriptor.class);
        if (devkit == null) {
          break;
        }
        boolean direct = role == DependencyUtil.Role.UsedDevkit;
        addDeps(result, devkit.getExtendedDevkits(), (direct ? DependencyUtil.Role.UsedDevkit : DependencyUtil.Role.DependencyDevkit), DependencyUtil.LinkType.ExtendsDevkit);
        addDeps(result, devkit.getExportedLanguages(), (direct ? DependencyUtil.Role.UsedLanguage : DependencyUtil.Role.DependencyLanguage), DependencyUtil.LinkType.ExportsLanguage);
        addDeps(result, devkit.getExportedSolutions(), (direct ? DependencyUtil.Role.RegularDependency : DependencyUtil.Role.RuntimeDependency), DependencyUtil.LinkType.ExportsSolution);
        break;

      case UsedLanguage:
        addExtendedLanguages(module, DependencyUtil.Role.UsedLanguage, result);
        if (myNeedRuntime) {
          for (SDependency dep : module.getDeclaredDependencies()) {
            if (dep.getScope() == SDependencyScope.DESIGN || dep.getScope() == SDependencyScope.EXTENDS) {
              continue;
            }
            ListSequence.fromList(result).addElement(regularDependencyPresentation(dep));
          }
          addDeps(result, as_he47wm_a0b0b0b0e3a6(module, Language.class).getRuntimeModulesReferences(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.ExportsRuntime);
        }
        break;

      case RegularDependency:
        for (SDependency dep : module.getDeclaredDependencies()) {
          if (dep.getScope() == SDependencyScope.DESIGN) {
            // design dependencies of our own dependencies are of no interest for the module, we don't see them 
            // and yes, regardless of myNeedRuntime setting (unlike top-level deps). 
            continue;
          }
          // We need all modules from dependencies to load a module and to execute code from it. Re-export is for scope and compile control 
          if (dep.isReexport()) {
            ListSequence.fromList(result).addElement(regularDependencyPresentation(dep));
          } else if (myNeedRuntime) {
            // not sure there's reason to tell regular dependency from runtime dependency 
            ListSequence.fromList(result).addElement(new DepLink(dep.getTargetModule(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.Depends));
          }
        }
        if (myNeedRuntime) {
          // at run time, we need dependencies of the languages our dependencies were written in 
          addUsedLanguagesAndDevkitsOf(module, result, false);
        }
        break;

      case RuntimeDependency:
        if (myNeedRuntime) {
          for (SDependency dep : module.getDeclaredDependencies()) {
            if (dep.getScope() == SDependencyScope.DESIGN) {
              continue;
            }
            ListSequence.fromList(result).addElement(new DepLink(dep.getTargetModule(), DependencyUtil.Role.RuntimeDependency, (dep.isReexport() ? DependencyUtil.LinkType.ReexportsDep : DependencyUtil.LinkType.Depends)));
          }
          addUsedLanguagesAndDevkitsOf(module, result, false);
        }
        if (module instanceof Generator) {
          ListSequence.fromList(result).addElement(new DepLink((as_he47wm_a0a0a0a0a0a1a6d0g(module, Generator.class)).sourceLanguage().getSourceModuleReference(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.GeneratorLanguage));
        }
        break;

      case SourceLanguage:
        // dependency from generator to its source language 
        addExtendedLanguages(module, DependencyUtil.Role.SourceLanguage, result);
        if (myNeedRuntime) {
          addDeps(result, as_he47wm_a0b0a0c0h3a6(module, Language.class).getRuntimeModulesReferences(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.ExportsRuntime);
        }
        break;

      case DependencyLanguage:
        addExtendedLanguages(module, DependencyUtil.Role.DependencyLanguage, result);
        addDeps(result, as_he47wm_a0b0b0i3a6(module, Language.class).getRuntimeModulesReferences(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.ExportsRuntime);
        break;

      default:
    }
    return result;
  }

  private void addUsedLanguagesAndDevkitsOf(SModule module, List<DepLink> result, boolean initialNotDependency) {
    if (!(module instanceof AbstractModule)) {
      for (SLanguage lang : module.getUsedLanguages()) {
        SModuleReference langSourceModule = lang.getSourceModuleReference();
        if (langSourceModule != null) {
          ListSequence.fromList(result).addElement(new DepLink(langSourceModule, (initialNotDependency ? DependencyUtil.Role.UsedLanguage : DependencyUtil.Role.DependencyLanguage), DependencyUtil.LinkType.UsesLanguage));
        }
      }
      return;
    }
    AbstractModule.LangAndDevkits actualUses = ((AbstractModule) module).collectLanguagesAndDevkits();
    Iterable<SModuleReference> languages = Sequence.fromIterable(((Iterable<SLanguage>) actualUses.languages)).select(new ISelector<SLanguage, SModuleReference>() {
      public SModuleReference select(SLanguage it) {
        return it.getSourceModuleReference();
      }
    });
    addDeps(result, Sequence.fromIterable(languages).where(new NotNullWhereFilter<SModuleReference>()), (initialNotDependency ? DependencyUtil.Role.UsedLanguage : DependencyUtil.Role.DependencyLanguage), DependencyUtil.LinkType.UsesLanguage);
    addDeps(result, actualUses.devkits, (initialNotDependency ? DependencyUtil.Role.UsedDevkit : DependencyUtil.Role.DependencyDevkit), DependencyUtil.LinkType.UsesDevkit);
  }

  private void addExtendedLanguages(SModule module, DependencyUtil.Role role, List<DepLink> result) {
    assert module instanceof Language;
    for (SDependency dep : module.getDeclaredDependencies()) {
      if (dep.getScope() == SDependencyScope.EXTENDS) {
        // Language can not extend anything but a language, that's why I don't care to check dep's target 
        ListSequence.fromList(result).addElement(new DepLink(dep.getTargetModule(), role, DependencyUtil.LinkType.ExtendsLanguage));
      }
    }
  }

  private static DepLink regularDependencyPresentation(SDependency dep) {
    switch (dep.getScope()) {
      case EXTENDS:
        SModule t = dep.getTarget();
        if (t instanceof Language) {
          return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RegularDependency, DependencyUtil.LinkType.ExtendsLanguage);
        } else if (t instanceof Generator) {
          return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RegularDependency, DependencyUtil.LinkType.ExtendsGenerator);
        } else {
          // just in case module could not be resolved 
          return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RegularDependency, DependencyUtil.LinkType.Depends);
        }
      case DESIGN:
        return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RegularDependency, DependencyUtil.LinkType.Depends);
      case RUNTIME:
        return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RuntimeDependency, DependencyUtil.LinkType.Depends);
      default:
        return new DepLink(dep.getTargetModule(), DependencyUtil.Role.RegularDependency, (dep.isReexport() ? DependencyUtil.LinkType.ReexportsDep : DependencyUtil.LinkType.Depends));
    }
  }

  public void addDeps(List<DepLink> result, Iterable<SModuleReference> modules, final DependencyUtil.Role role, final DependencyUtil.LinkType linktype) {
    if (modules == null) {
      return;
    }
    ListSequence.fromList(result).addSequence(Sequence.fromIterable(modules).select(new ISelector<SModuleReference, DepLink>() {
      public DepLink select(SModuleReference module) {
        return new DepLink(module, role, linktype);
      }
    }));
  }
  private static Iterable<SModuleReference> getReexportDeps(SModule module) {
    return Sequence.fromIterable(((Iterable<SDependency>) module.getDeclaredDependencies())).where(new IWhereFilter<SDependency>() {
      public boolean accept(SDependency dep) {
        return dep.isReexport();
      }
    }).select(new ISelector<SDependency, SModuleReference>() {
      public SModuleReference select(SDependency dep) {
        return dep.getTargetModule();
      }
    });
  }
  private static Iterable<SModuleReference> getNonreexportDeps(ModuleDescriptor descr) {
    return SetSequence.fromSet(((Set<jetbrains.mps.project.structure.modules.Dependency>) descr.getDependencies())).where(new IWhereFilter<jetbrains.mps.project.structure.modules.Dependency>() {
      public boolean accept(jetbrains.mps.project.structure.modules.Dependency dep) {
        return !(dep.isReexport());
      }
    }).select(new ISelector<jetbrains.mps.project.structure.modules.Dependency, SModuleReference>() {
      public SModuleReference select(jetbrains.mps.project.structure.modules.Dependency dep) {
        return dep.getModuleRef();
      }
    });
  }
  public enum LinkType {
    Depends("depends on"),
    ReexportsDep("reexports dependency on"),
    UsesLanguage("uses language"),
    ExtendsLanguage("extends language"),
    ExtendsGenerator("extends generator"),
    ExportsRuntime("exports runtime"),
    ExportsRuntimeLib("has runtime library"),
    UsesDevkit("uses devkit"),
    ExportsLanguage("exports language"),
    ExportsSolution("exports solution"),
    ExtendsDevkit("extends devkit"),
    GeneratorLanguage("generator language"),
    DependsOnGenerator("depends on generator"),
    Generator("generator"),
    LangCore("");

    private String myText;
    LinkType(String text) {
      myText = text;
    }
    @Override
    public String toString() {
      return myText;
    }
  }
  /**
   * None is a fake role to get initial set of dependencies
   * UsedLanguage reflects language in use by the module. languages extended by UsedLanguage are reflected with the same role, too.
   * DependencyLanguage language in use by a module dependency other than 'used language'
   * UsedDevkit - explicit devkit dependency, direct or indirect (i.e. devkit1 extends devkit2
   * DependencyDevkit - devkit dependencies from a module dependency other than 'UsedDevkit' (indirectly involved devkits)
   * RegularDependency - direct or indirect dependency of original module
   * OwnedGenerator - dependency between a language and its generators
   * SourceLanguage - dependency from generator to its owning language
   */
  public enum Role {
    None(),
    RegularDependency(),
    RuntimeDependency(),
    UsedLanguage(),
    DependencyLanguage(),
    UsedDevkit(),
    DependencyDevkit(),
    SourceLanguage(),
    OwnedGenerator();

    Role() {
    }
    public boolean isUsedLanguage() {
      return this == DependencyUtil.Role.UsedLanguage;
    }
    public boolean isDependency() {
      return this == DependencyUtil.Role.RegularDependency || this == DependencyUtil.Role.OwnedGenerator || this == DependencyUtil.Role.RuntimeDependency;
    }
  }
  public static class Dependency extends MultiTuple._2<SModuleReference, DependencyUtil.Role> {
    public Dependency() {
      super();
    }
    public Dependency(SModuleReference module, DependencyUtil.Role role) {
      super(module, role);
    }
    public SModuleReference module(SModuleReference value) {
      return super._0(value);
    }
    public DependencyUtil.Role role(DependencyUtil.Role value) {
      return super._1(value);
    }
    public SModuleReference module() {
      return super._0();
    }
    public DependencyUtil.Role role() {
      return super._1();
    }
  }
  private static <T> T as_he47wm_a0a1a3d0g(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_he47wm_a0b0b0b0e3a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_he47wm_a0a0a0a0a0a1a6d0g(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_he47wm_a0b0a0c0h3a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_he47wm_a0b0b0i3a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
