package jetbrains.mps.debugger.java.runtime.state;

/*Generated by MPS */

import jetbrains.mps.debugger.java.api.state.JavaUiState;
import java.util.List;
import jetbrains.mps.debugger.java.api.state.proxy.JavaThread;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.debugger.java.runtime.engine.events.Context;
import java.util.Objects;
import jetbrains.mps.debugger.java.runtime.engine.events.EventsProcessor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.debug.api.AbstractDebugSession;
import com.sun.jdi.ThreadReference;
import jetbrains.mps.debug.api.programState.IThread;
import jetbrains.mps.debug.api.AbstractUiState;

public abstract class JavaUiStateImpl extends JavaUiState {
  protected final DebugSession myDebugSession;
  protected int myThreadIndex;
  protected final List<JavaThread> myThreads = ListSequence.fromList(new ArrayList<JavaThread>());
  public JavaUiStateImpl(@NotNull DebugSession session) {
    super(session);
    myDebugSession = session;
    myThreadIndex = -1;
  }
  /**
   * This constructor is called when user selects some thread from ui
   */
  protected JavaUiStateImpl(DebugSession debugSession, int currentThreadIndex) {
    this(debugSession);
    myThreadIndex = currentThreadIndex;
    assert currentThreadIndex >= 0;

    initializeThreads();

    ListSequence.fromList(myThreads).visitAll(new IVisitor<JavaThread>() {
      public void visit(JavaThread it) {
        it.initializeFrames();
      }
    });
  }
  public abstract Context getContext();
  @Override
  public abstract boolean isPausedOnBreakpoint();
  @NotNull
  /*package*/ PausedJavaUiState paused(@NotNull Context context) {
    //  changes state on pause/resume 
    //  we select new context even if we are already on some other context 
    //  user probably wants to know about new paused contexts 
    return new PausedJavaUiState(context, myDebugSession);
  }
  @NotNull
  /*package*/ JavaUiStateImpl resumed(Context context) {
    if (context != getContext()) {
      return this;
    }
    Context newContext = getEventProcessor().getContextManager().firstContext();
    if (newContext == null) {
      return new RunningJavaUiState(myDebugSession);
    }
    return new PausedJavaUiState(newContext, myDebugSession);
  }
  protected Context findContext(@NotNull JavaUiStateImpl previousState) {
    Context newContext = previousState.getContext();
    JavaThread thread = getThread();
    if (thread == null) {
      return null;
    }
    if (newContext == null || !((Objects.equals(newContext.getThread(), thread)))) {
      return getEventProcessor().getContextManager().findContextForThread(thread.getThread());
    }
    return newContext;
  }
  protected EventsProcessor getEventProcessor() {
    return myDebugSession.getEventsProcessor();
  }
  @Override
  public void invokeEvaluation(_FunctionTypes._void_P0_E0 command) {
    if (getContext() == null) {
      return;
    }
    myDebugSession.getEventsProcessor().scheduleEvaluation(command, getThread().getThread());
  }
  @Override
  @Nullable
  public <R> R invokeEvaluationSynchronously(_FunctionTypes._return_P0_E0<? extends R> command) {
    if (getContext() == null) {
      return null;
    }
    return myDebugSession.getEventsProcessor().invokeEvaluationUnderProgress(command, getThread().getThread());
  }
  protected synchronized void initializeThreads() {
    assert !(ThreadUtils.isInEDT());
    assert getExecutionState().equals(AbstractDebugSession.ExecutionState.Paused);

    for (ThreadReference threadReference : getEventProcessor().getVirtualMachine().allThreads()) {
      ListSequence.fromList(myThreads).addElement(new JavaThread(myDebugSession, threadReference));
    }
    assert myThreadIndex < ListSequence.fromList(myThreads).count();
  }
  @Nullable
  public JavaThread getCurrentThread() {
    return ListSequence.fromList(myThreads).getElement(myThreadIndex);
  }
  @Override
  protected JavaUiStateImpl selectThreadInternal(@Nullable IThread thread) {
    //  changes state on user selection 
    int index = ListSequence.fromList(myThreads).indexOf(thread);
    if (((JavaThread) thread).getThread().isSuspended()) {
      return new PausedJavaUiState(this, myDebugSession, index);
    }
    return new RunningJavaUiState(myDebugSession, index);
  }
  @Override
  public void selectThread(@Nullable final IThread thread) {
    myDebugSession.getEventsProcessor().schedule(new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        AbstractUiState newState = selectThreadInternal(thread);
        if (newState != JavaUiStateImpl.this) {
          myAbstractDebugSession.trySetState(JavaUiStateImpl.this, newState);
        }
      }
    });
  }
  @NotNull
  @Override
  public synchronized List<JavaThread> getThreads() {
    return myThreads;
  }
  @Override
  public synchronized JavaThread getThread() {
    return (JavaThread) ListSequence.fromList(myThreads).getElement(myThreadIndex);
  }
  protected AbstractDebugSession.ExecutionState getExecutionState() {
    return myDebugSession.getExecutionState();
  }
}
