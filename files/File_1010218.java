package jetbrains.mps.checkers;

/*Generated by MPS */

import jetbrains.mps.errors.item.NodeReportItem;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.util.Consumer;
import org.jetbrains.mps.openapi.util.ProgressMonitor;

public abstract class AbstractNodeCheckerInEditor extends IChecker.AbstractNodeChecker<NodeReportItem> {
  public static final IChecker.AbstractNodeChecker.ErrorSkipCondition SKIP_CONSTRAINTS_CONDITION = new IChecker.AbstractNodeChecker.ErrorSkipCondition() {
    public boolean skipSingleNode(SNode node) {
      return false;
    }
    public boolean skipSubtree(SNode root) {
      return SNodeOperations.isInstanceOf(root, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x50ef06e32fec9043L, "jetbrains.mps.lang.core.structure.ISkipConstraintsChecking"));
    }
  };
  protected abstract void checkNodeInEditor(SNode node, LanguageErrorsCollector errorsCollector, SRepository repository);

  @Override
  public final void check(SNode toCheck, SRepository repository, final Consumer<? super NodeReportItem> errorCollector, ProgressMonitor monitor) {
    checkNodeInEditor(toCheck, new LanguageErrorsCollector() {
      protected void addErrorInternal(NodeReportItem reportItem) {
        errorCollector.consume(reportItem);
      }
    }, repository);
  }
}
