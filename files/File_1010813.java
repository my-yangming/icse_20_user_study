package jetbrains.mps.editor.runtime.impl.cellActions;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;

public class NodeUncommenter {
  @NotNull
  private final SNode myComment;

  private SNode myParent;
  private SContainmentLink myContainmentLink;



  public NodeUncommenter(@NotNull SNode nodeToUncomment) {
    myComment = nodeToUncomment;
  }

  /**
   * Uncomments the node which is under the comment node specified in constructor
   * <p></p>
   * Also if containment link of the commented node is singular and non optional comments or deletes the existing child whether it is instance of abstract concept or not respectively
   * 
   * @throws IllegalStateException if node to uncomment does not have parent
   * @return node which was under the comment
   */
  public SNode uncomment() {
    if (!(isValid())) {
      throw new IllegalStateException("Node uncommenter has invalid state. Comment attribute has no parent. Attribute " + myComment.getPresentation() + " Attribute id: " + myComment.getNodeId());
    }
    SNode commentedNode = SLinkOperations.getTarget(myComment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
    if (getContainmentLink() != null && commentedNode != null) {
      removeOrCommentChildInSingleRole();
      myComment.removeChild(commentedNode);
      getParent().insertChildAfter(getContainmentLink(), commentedNode, myComment);
    }
    SNodeOperations.deleteNode(myComment);
    return commentedNode;
  }
  private void removeOrCommentChildInSingleRole() {
    if (!(getContainmentLink().isMultiple())) {
      SNode firstChild = ListSequence.fromList(SNodeOperations.getChildren(getParent(), getContainmentLink())).first();
      if ((firstChild != null)) {
        if (firstChild.getConcept().isAbstract()) {
          SNodeOperations.deleteNode(firstChild);
        } else {
          new NodeCommenter(firstChild).commentOut(false);
        }
      }
    }
  }

  public boolean isValid() {
    if ((getParent() == null)) {
      return false;
    }
    return true;
  }

  private SNode getParent() {
    if (myParent == null) {
      myParent = SNodeOperations.getParent(myComment);
    }
    return myParent;
  }
  private SContainmentLink getContainmentLink() {
    if (myContainmentLink == null) {
      myContainmentLink = ((SContainmentLink) BHReflection.invoke0(myComment, MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x9d98713f247885aL, "jetbrains.mps.lang.core.structure.ChildAttribute"), SMethodTrimmedId.create("getLink", MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x9d98713f247885aL, "jetbrains.mps.lang.core.structure.ChildAttribute"), "BpxLfMirzf")));
    }
    return myContainmentLink;
  }
}
