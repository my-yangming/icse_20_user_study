package jetbrains.mps.execution.api.configurations;

/*Generated by MPS */

import com.intellij.execution.configurations.ConfigurationFactory;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.configurations.RunConfiguration;
import com.intellij.openapi.project.Project;
import java.lang.reflect.Constructor;
import org.apache.log4j.Level;
import com.intellij.execution.configurations.UnknownRunConfiguration;
import com.intellij.openapi.util.Key;
import com.intellij.execution.BeforeRunTask;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * Non-reloadable factory for Run Configurations. Instances of this class are safe to operate even once original 
 * MPS module that contributed them (with a help of app plugin part) has been disposed - IDEA's RunnerAndConfigurationSettingsImpl holds
 * run configuration instance and accesses its factory.
 */
/*package*/ final class ConfigFactoryEnvoy extends ConfigurationFactory {
  private static final Logger LOG = LogManager.getLogger(ConfigFactoryEnvoy.class);
  private boolean myIsIvalid;
  private final Class<? extends BaseMpsRunConfiguration> myDelegateClass;
  private final String myName;

  /*package*/ ConfigFactoryEnvoy(@NotNull ConfigTypeEnvoy configType, @NotNull Class<? extends BaseMpsRunConfiguration> delegateClass, String name) {
    super(configType);
    myDelegateClass = delegateClass;
    myName = name;
  }

  /*package*/ Class<?> getRunConfigClass() {
    return myDelegateClass;
  }

  /**
   * Factory may get invalidated independent from ConfigurationType (i.e. if the latter is defined in another, non-reloaded plugin)
   */
  /*package*/ void invalidate() {
    // package-local, perhaps, with ConfigType.invalidateFactory(Class<RunConfiguration>) 
    myIsIvalid = true;
    //  perhaps, shall nullify myDelegateClass to release any reference to stale class? 
  }

  @NotNull
  @Override
  public String getId() {
    // though javadoc in superclass suggests to use getType().getId(), it doesn't allow to distinguish multiple factories for the same type 
    // However, would be better to distinguish id from user-friendly name 
    return myName;
  }

  @Override
  @NotNull
  public String getName() {
    return myName;
  }

  @NotNull
  @Override
  public RunConfiguration createTemplateConfiguration(@NotNull Project project) {
    try {
      // Constructor signature to match one in weave_RunConfigurationConstructor 
      Constructor<? extends BaseMpsRunConfiguration> c = myDelegateClass.getConstructor(Project.class, ConfigurationFactory.class, String.class);
      return c.newInstance(project, this, "");
    } catch (Exception ex) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error(String.format("Failed to instantiate run configuration %s of type %s", myDelegateClass.getName(), getId()), ex);
      }
      return new UnknownRunConfiguration(this, project);
    }
  }

  @Override
  public void configureBeforeRunTaskDefaults(Key<? extends BeforeRunTask> providerID, BeforeRunTask task) {
    try {
      Method method = myDelegateClass.getMethod("configureBeforeTaskDefaults", Key.class, BeforeRunTask.class);
      method.invoke(null, providerID, task);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    } catch (InvocationTargetException e) {
      e.printStackTrace();
    }
  }

  /**
   * 
   * @return true iff this factory has not been notified that 
   */
  /*package*/ boolean isValid() {
    return !(myIsIvalid);
  }


  @Override
  public String toString() {
    if (isValid()) {
      return String.format("Factory for %s", myName);
    } else {
      return String.format("Factory for %s, INVALID", myName);
    }
  }
}
