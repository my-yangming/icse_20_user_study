package jetbrains.mps.debugger.java.runtime.evaluation.proxies;

/*Generated by MPS */

import jetbrains.mps.debugger.java.api.evaluation.proxies.ValueProxy;
import jetbrains.mps.debugger.java.api.evaluation.proxies.IObjectValueProxy;
import com.sun.jdi.ClassType;
import com.sun.jdi.ObjectReference;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debugger.java.api.evaluation.proxies.IValueProxy;
import jetbrains.mps.debugger.java.api.evaluation.InvalidEvaluatedExpressionException;
import com.sun.jdi.Field;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationUtils;
import com.sun.jdi.Value;
import jetbrains.mps.debugger.java.api.evaluation.proxies.MirrorUtil;
import java.util.List;
import java.util.ArrayList;
import com.sun.jdi.ThreadReference;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import com.sun.jdi.Method;
import com.sun.jdi.InvocationException;
import com.sun.jdi.InvalidTypeException;
import com.sun.jdi.ClassNotLoadedException;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.StringReference;

/*package*/ class ObjectValueProxy extends ValueProxy implements IObjectValueProxy {
  private ClassType myReferenceType;
  public ObjectValueProxy(ObjectReference v) {
    super(v);
    myReferenceType = (ClassType) v.referenceType();
  }
  @NotNull
  private ObjectReference getObjectValue() {
    return (ObjectReference) myValue;
  }
  @NotNull
  @Override
  public IValueProxy getFieldValue(String fieldName) throws InvalidEvaluatedExpressionException {
    ObjectReference value = getObjectValue();
    Field f = EvaluationUtils.getInstance().findField(myReferenceType, fieldName);
    Value result = value.getValue(f);
    return MirrorUtil.getInstance().getValueProxy(result);
  }
  public List<IValueProxy> getFieldValues() {
    List<Field> fields = EvaluationUtils.getInstance().findFields(myReferenceType);
    List<IValueProxy> fieldValues = new ArrayList<IValueProxy>();
    for (Field field : fields) {
      fieldValues.add(MirrorUtil.getInstance().getValueProxy(getObjectValue().getValue(field)));
    }
    return fieldValues;
  }
  @Override
  public IValueProxy invokeMethod(String name, String jniSignature, ThreadReference threadReference, Object... args) throws EvaluationException {
    ClassType classType = myReferenceType;
    int options = 0;
    return invoke(name, jniSignature, classType, options, threadReference, args);
  }
  @Override
  public IValueProxy invokeSuperMethod(String name, String jniSignature, ThreadReference threadReference, Object... args) throws EvaluationException {
    ClassType classType = myReferenceType;
    ClassType superclass = classType.superclass();
    if (superclass == null) {
      throw new InvalidEvaluatedExpressionException("Can't invoke super method: class " + classType.name() + " has no superclasses.");
    }
    int options = ObjectReference.INVOKE_NONVIRTUAL;
    return invoke(name, jniSignature, superclass, options, threadReference, args);
  }
  @Override
  public boolean isInstanceOf(String typename) throws EvaluationException {
    return EvaluationUtils.getInstance().instanceOf(myReferenceType, typename, myValue.virtualMachine());
  }
  protected IValueProxy invoke(String name, String jniSignature, ClassType classType, final int options, final ThreadReference threadReference, Object[] args) throws EvaluationException {
    // TODO merge with Evaluator methods invocation 
    final Method method = classType.concreteMethodByName(name, jniSignature);
    if (method == null) {
      throw new InvalidEvaluatedExpressionException("Concrete method " + name + " with signature " + jniSignature + " not found in " + classType + ".");
    }
    final List<Value> argValues = MirrorUtil.getInstance().getValues(myValue.virtualMachine(), args);
    return EvaluationUtils.handleInvocationExceptions(new EvaluationUtils.ThreadInvocatable<IValueProxy>(threadReference) {
      @Override
      public IValueProxy invoke() throws InvocationException, InvalidTypeException, ClassNotLoadedException, IncompatibleThreadStateException {
        Value result = getObjectValue().invokeMethod(threadReference, method, argValues, options);
        return MirrorUtil.getInstance().getValueProxy(result);
      }
    });
  }
  @Override
  public boolean javaEquals(IValueProxy proxy) {
    return myValue.equals(proxy.getJDIValue());
  }
  public String getPresentation() {
    if (myValue instanceof StringReference) {
      return "\"" + ((StringReference) myValue).value() + "\"";
    }
    return (("{" + myValue.type().name() + "} ") + myValue.toString());
  }
}
