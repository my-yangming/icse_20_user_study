package jetbrains.mps.vcs.annotate;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.leftHighlighter.AbstractLeftColumn;
import java.awt.Color;
import jetbrains.mps.openapi.editor.style.StyleRegistry;
import java.awt.Font;
import jetbrains.mps.nodeEditor.EditorSettings;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.vcs.annotate.FileAnnotation;
import com.intellij.openapi.vcs.history.VcsRevisionNumber;
import com.intellij.openapi.vcs.history.VcsFileRevision;
import com.intellij.openapi.vcs.annotate.LineAnnotationAspect;
import org.jetbrains.mps.openapi.model.EditableSModel;
import jetbrains.mps.smodel.persistence.lines.LineContent;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.Set;
import com.intellij.util.messages.MessageBusConnection;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import jetbrains.mps.nodeEditor.leftHighlighter.LeftEditorHighlighter;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import com.intellij.openapi.vcs.actions.AnnotationColors;
import com.intellij.ui.ColorUtil;
import org.jetbrains.mps.openapi.module.SRepository;
import com.intellij.openapi.project.Project;
import jetbrains.mps.vcs.changesmanager.CurrentDifference;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.nodeEditor.highlighter.EditorComponentCreateListener;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.smodel.persistence.lines.PropertyLineContent;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.smodel.persistence.lines.ReferenceLineContent;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.smodel.persistence.lines.NodeLineContent;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.FontRegistry;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.util.Condition;
import jetbrains.mps.nodeEditor.messageTargets.CellFinder;
import jetbrains.mps.nodeEditor.cells.CellFinderUtil;
import java.util.Collections;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.closures.runtime.YieldingIterator;
import jetbrains.mps.openapi.editor.cells.EditorCell_Collection;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import java.awt.event.MouseEvent;
import java.awt.Cursor;
import com.intellij.openapi.vcs.annotate.LineAnnotationAspectAdapter;
import javax.swing.JPopupMenu;
import com.intellij.openapi.actionSystem.AnAction;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.Separator;
import com.intellij.openapi.ide.CopyPasteManager;
import com.intellij.util.ui.TextTransferable;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceAdapter;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.vcs.diff.ChangeSet;

public class AnnotationColumn extends AbstractLeftColumn {
  private static final Color ANNOTATION_COLOR = StyleRegistry.getInstance().getColor("ANNOTATIONS_COLOR");
  private Font myFont = EditorSettings.getInstance().getDefaultEditorFont();
  private List<AnnotationAspectSubcolumn> myAspectSubcolumns = ListSequence.fromList(new ArrayList<AnnotationAspectSubcolumn>());
  private List<Integer> myPseudoLinesY;
  private List<AnnotationColumn.LineRevisionRecord> myEditorLineRecords;
  private int mySubcolumnInterval;
  private Map<String, Color> myAuthorsToColors = MapSequence.fromMap(new HashMap<String, Color>());
  private final FileAnnotation myFileAnnotation;
  private Map<VcsRevisionNumber, VcsFileRevision> myRevisionNumberToRevision = MapSequence.fromMap(new HashMap<VcsRevisionNumber, VcsFileRevision>());
  private LineAnnotationAspect myAuthorAnnotationAspect;
  private final EditableSModel myModel;
  private final List<LineContent> myFileLineToContent;
  private Map<ModelChange, LineContent[]> myChangesToLineContents = MapSequence.fromMap(new HashMap<ModelChange, LineContent[]>());
  private Set<Integer> myCurrentPseudoLines = null;
  private VcsRevisionRange myRevisionRange;
  private ViewActionGroup myViewActionGroup;
  private AnnotationColumn.MyDifferenceListener myDifferenceListener = new AnnotationColumn.MyDifferenceListener();
  private boolean myShowAdditionalInfo = false;
  private MessageBusConnection myMessageBusConnection;
  private final CurrentDifferenceRegistry myDiffRegistry;


  /*package*/ AnnotationColumn(LeftEditorHighlighter leftEditorHighlighter, SNode root, @NotNull FileAnnotation fileAnnotation, @NotNull List<LineContent> lineToContent) {
    super(leftEditorHighlighter);
    myModel = (EditableSModel) SNodeOperations.getModel(root);
    myFileAnnotation = fileAnnotation;
    myFileLineToContent = lineToContent;
    myAuthorAnnotationAspect = Sequence.fromIterable(Sequence.fromArray(myFileAnnotation.getAspects())).findFirst(new IWhereFilter<LineAnnotationAspect>() {
      public boolean accept(LineAnnotationAspect a) {
        return LineAnnotationAspect.AUTHOR.equals(a.getId());
      }
    });
    ListSequence.fromList(myAspectSubcolumns).addSequence(Sequence.fromIterable(Sequence.fromArray(fileAnnotation.getAspects())).select(new ISelector<LineAnnotationAspect, AnnotationAspectSubcolumn>() {
      public AnnotationAspectSubcolumn select(LineAnnotationAspect a) {
        return new AnnotationAspectSubcolumn(AnnotationColumn.this, a);
      }
    }));
    ListSequence.fromList(myAspectSubcolumns).addElement(new CommitNumberSubcolumn(this, myFileAnnotation));
    for (VcsFileRevision revision : ListSequence.fromList(myFileAnnotation.getRevisions())) {
      String author = revision.getAuthor();
      if (!(MapSequence.fromMap(myAuthorsToColors).containsKey(author))) {
        Color color = AnnotationColors.BG_COLORS[MapSequence.fromMap(myAuthorsToColors).count() % AnnotationColors.BG_COLORS.length];
        if (StyleRegistry.getInstance().isDarkTheme()) {
          color = ColorUtil.shift(color, 0.3);
        }
        MapSequence.fromMap(myAuthorsToColors).put(author, color);
      }
      //  XXX can use FA.getCurrentFileRevisionProvider() 
      MapSequence.fromMap(myRevisionNumberToRevision).put(revision.getRevisionNumber(), revision);
    }
    myViewActionGroup = new ViewActionGroup(this, myAspectSubcolumns);
    myRevisionRange = new VcsRevisionRange(this);
    ListSequence.fromList(myAspectSubcolumns).addElement(new HighlightRevisionSubcolumn(this, myRevisionRange));
    final SRepository editorRepo = getEditorComponent().getEditorContext().getRepository();
    final Project ideaProject = fileAnnotation.getProject();
    myDiffRegistry = CurrentDifferenceRegistry.getInstance(ideaProject);
    myDiffRegistry.getCommandQueue().runTask(new Runnable() {
      public void run() {
        final CurrentDifference currentDifference = myDiffRegistry.getCurrentDifference(myModel);
        editorRepo.getModelAccess().runReadAction(new Runnable() {
          public void run() {
            ListSequence.fromList(check_5mnya_a0a0a0a1a0a0o0w(currentDifference.getChangeSet())).visitAll(new IVisitor<ModelChange>() {
              public void visit(ModelChange ch) {
                saveChange(ch);
              }
            });
          }
        });
        currentDifference.addDifferenceListener(myDifferenceListener);
      }
    });
    myMessageBusConnection = ideaProject.getMessageBus().connect();
    myMessageBusConnection.subscribe(EditorComponentCreateListener.EDITOR_COMPONENT_CREATION, new AnnotationColumn.MyEditorComponentCreateListener());
  }
  private void saveChange(ModelChange ch) {
    if (ch instanceof SetPropertyChange) {
      SetPropertyChange spc = (SetPropertyChange) ch;
      MapSequence.fromMap(myChangesToLineContents).put(ch, new LineContent[]{new PropertyLineContent(spc.getAffectedNodeId(), spc.getProperty())});
    } else if (ch instanceof SetReferenceChange) {
      SetReferenceChange src = (SetReferenceChange) ch;
      MapSequence.fromMap(myChangesToLineContents).put(ch, new LineContent[]{new ReferenceLineContent(src.getAffectedNodeId(), src.getRoleLink())});
    } else if (ch instanceof NodeGroupChange) {
      NodeGroupChange ngc = (NodeGroupChange) ch;
      Iterable<SNode> newChildren = AttributeOperations.getChildNodesAndAttributes(((SNode) myModel.getNode(ngc.getParentNodeId())), ngc.getRoleLink());
      MapSequence.fromMap(myChangesToLineContents).put(ch, Sequence.fromIterable(newChildren).page(ngc.getResultBegin(), ngc.getResultEnd()).select(new ISelector<SNode, NodeLineContent>() {
        public NodeLineContent select(SNode n) {
          return new NodeLineContent(n.getNodeId());
        }
      }).toGenericArray(NodeLineContent.class));
    }
  }
  private void calculateCurrentPseudoLinesLater() {
    EditorComponent ec = getEditorComponent();
    if (ec == null || ec.isDisposed()) {
      return;
    }
    ec.getEditorContext().getRepository().getModelAccess().runReadInEDT(new Runnable() {
      public void run() {
        myCurrentPseudoLines = SetSequence.fromSet(new HashSet<Integer>());
        for (LineContent[] lineContents : MapSequence.fromMap(myChangesToLineContents).values()) {
          for (LineContent lc : lineContents) {
            SetSequence.fromSet(myCurrentPseudoLines).addSequence(Sequence.fromIterable(getPseudoLinesForContent(lc)));
          }
        }
        getLeftEditorHighlighter().repaint();
      }
    });
  }
  @Override
  public String getName() {
    return "Annotations";
  }
  @Override
  public void paint(Graphics graphics) {
    graphics.setFont(myFont);
    final Font boldFont = FontRegistry.getInstance().getFont(myFont.getName(), myFont.getStyle() | Font.BOLD, myFont.getSize());
    EditorComponent.turnOnAliasingIfPossible((Graphics2D) graphics);
    Map<AnnotationAspectSubcolumn, Integer> subcolumnToX = MapSequence.fromMap(new HashMap<AnnotationAspectSubcolumn, Integer>());
    int x = getX() + 1;
    for (AnnotationAspectSubcolumn subcolumn : ListSequence.fromList(myAspectSubcolumns)) {
      MapSequence.fromMap(subcolumnToX).put(subcolumn, x);
      if (subcolumn.isEnabled() || myShowAdditionalInfo) {
        x += subcolumn.getWidth() + mySubcolumnInterval;
      }
    }
    for (int pseudoLine = 0; pseudoLine < ListSequence.fromList(myPseudoLinesY).count(); pseudoLine++) {
      if (SetSequence.fromSet(myCurrentPseudoLines).contains(pseudoLine)) {
        continue;
      }
      AnnotationColumn.LineRevisionRecord record = ListSequence.fromList(myEditorLineRecords).getElement(pseudoLine);
      if (record == null) {
        // XXX is it possible to face this? Previous code didn't account for myPseudoLinesToFileLines[pseudoLine] == -1 
        continue;
      }

      int height = (pseudoLine == ListSequence.fromList(myPseudoLinesY).count() - 1 ? getEditorComponent().getHeight() - ListSequence.fromList(myPseudoLinesY).last() : ListSequence.fromList(myPseudoLinesY).getElement(pseudoLine + 1) - ListSequence.fromList(myPseudoLinesY).getElement(pseudoLine));
      if (myAuthorAnnotationAspect != null && ViewAction.isSet(ViewAction.COLORS)) {
        String author = record.rev.getAuthor();
        graphics.setColor(MapSequence.fromMap(myAuthorsToColors).get(author));
        graphics.fillRect(getX(), ListSequence.fromList(myPseudoLinesY).getElement(pseudoLine), getWidth(), height);
      }

      graphics.setColor(ANNOTATION_COLOR);
      if (myRevisionRange.isRevisionHighlighted(record.rev)) {
        graphics.setFont(boldFont);
      } else {
        graphics.setFont(myFont);
      }
      FontMetrics metrics = graphics.getFontMetrics();
      if (height < metrics.getHeight()) {
        continue;
      }
      for (AnnotationAspectSubcolumn subcolumn : ListSequence.fromList(myAspectSubcolumns).where(new IWhereFilter<AnnotationAspectSubcolumn>() {
        public boolean accept(AnnotationAspectSubcolumn s) {
          return myShowAdditionalInfo || s.isEnabled();
        }
      })) {
        String text = subcolumn.getTextForFileLine(record);
        int textX = MapSequence.fromMap(subcolumnToX).get(subcolumn);
        if (subcolumn.isRightAligned()) {
          textX += subcolumn.getWidth() - metrics.stringWidth(text);
        }
        graphics.drawString(text, textX, metrics.getAscent() + ListSequence.fromList(myPseudoLinesY).getElement(pseudoLine));
      }
    }
  }
  @Override
  public int getWidth() {
    return (ListSequence.fromList(myAspectSubcolumns).isEmpty() ? 0 : ListSequence.fromList(myAspectSubcolumns).select(new ISelector<AnnotationAspectSubcolumn, Integer>() {
      public Integer select(AnnotationAspectSubcolumn s) {
        return (s.isEnabled() || myShowAdditionalInfo ? s.getWidth() : 0);
      }
    }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
      public Integer combine(Integer a, Integer b) {
        return a + mySubcolumnInterval + b;
      }
    }) + 1 + mySubcolumnInterval / 2);
  }

  @Nullable
  private VcsFileRevision fileRevForLine(int fileLine) {
    return MapSequence.fromMap(myRevisionNumberToRevision).get(myFileAnnotation.getLineRevisionNumber(fileLine));
  }

  @Nullable
  private EditorCell findCellForContent(@Nullable LineContent content) {
    if (content == null) {
      return null;
    }
    EditorComponent editor = getEditorComponent();
    SNode editedNode = editor.getEditedNode();
    SNode node = editedNode.getModel().getNode(content.getNodeId());
    if (node == null || !(ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).contains(editedNode))) {
      return null;
    }

    jetbrains.mps.nodeEditor.cells.EditorCell bigCellForNode = editor.getBigValidCellForNode(node);
    if (bigCellForNode == null) {
      return null;
    }

    if (content instanceof NodeLineContent) {
      // FIXME treat node annotations so that they don't grab chnages of the annotated node just because they are 'big' cells 
      return bigCellForNode;
    } else if (content instanceof PropertyLineContent) {
      PropertyLineContent plc = (PropertyLineContent) content;
      final Condition<EditorCell> isPropCell;
      if (plc.getProperty() != null) {
        isPropCell = new CellFinder.CellForPropertyCondition(node, plc.getProperty());
      } else {
        isPropCell = new CellFinder.CellForPropertyLegacyCondition(node, plc.getName());
      }
      return CellFinderUtil.findChildByCondition(bigCellForNode, isPropCell, true, true);
    } else if (content instanceof ReferenceLineContent) {
      ReferenceLineContent rlc = (ReferenceLineContent) content;
      final Condition<EditorCell> isRefCell;
      if (rlc.getLink() != null) {
        isRefCell = new CellFinder.CellForReferenceCondition(node, rlc.getLink());
      } else {
        isRefCell = new CellFinder.CellForReferenceLegacyCondition(node, rlc.getRole());
      }
      return CellFinderUtil.findChildByCondition(bigCellForNode, isRefCell, true, true);
    } else {
      return null;
    }

  }
  private Iterable<Integer> getPseudoLinesForContent(@Nullable LineContent content) {
    // XXX what makes me feel uneasy is that findCellForContent gives whole node cell in case respective cell for Property/Reference LineContent have not been found 
    //     On one hand, the change is indeed there and we might want to reflect the fact node has been changed. OTOH, it might be technical/private property not reflected in the editor and 
    //     there's no reason to tell it's a change for complete node. 
    EditorCell cell = findCellForContent(content);
    if (cell == null) {
      return Sequence.fromIterable(Collections.<Integer>emptyList());
    }
    final int startPseudoLine = Collections.binarySearch((List) myPseudoLinesY, cell.getY());
    final Wrappers._int endPseudoLine = new Wrappers._int(Collections.binarySearch((List) myPseudoLinesY, cell.getY() + cell.getHeight()));
    if (endPseudoLine.value < 0) {
      endPseudoLine.value = -endPseudoLine.value - 1;
    }
    return new _FunctionTypes._return_P0_E0<Iterable<Integer>>() {
      public Iterable<Integer> invoke() {
        return new Iterable<Integer>() {
          public Iterator<Integer> iterator() {
            return new YieldingIterator<Integer>() {
              private int __CP__ = 0;
              protected boolean moveToNext() {
__loop__:
                do {
__switch__:
                  switch (this.__CP__) {
                    case -1:
                      assert false : "Internal error";
                      return false;
                    case 2:
                      this._2_pseudoLine = startPseudoLine;
                    case 3:
                      if (!(_2_pseudoLine < endPseudoLine.value)) {
                        this.__CP__ = 1;
                        break;
                      }
                      this.__CP__ = 4;
                      break;
                    case 5:
                      _2_pseudoLine++;
                      this.__CP__ = 3;
                      break;
                    case 6:
                      this.__CP__ = 5;
                      this.yield(_2_pseudoLine);
                      return true;
                    case 0:
                      this.__CP__ = 2;
                      break;
                    case 4:
                      this.__CP__ = 6;
                      break;
                    default:
                      break __loop__;
                  }
                } while (true);
                return false;
              }
              private int _2_pseudoLine;
            };
          }
        };
      }
    }.invoke();
  }
  @Override
  public void relayout() {
    EditorComponent editor = getEditorComponent();
    if (editor == null || editor.isDisposed()) {
      return;
    }
    Iterable<EditorCell> nonTrivialCells = Sequence.fromIterable(EditorUtils.getCellDescendants(editor.getRootCell())).where(new IWhereFilter<EditorCell>() {
      public boolean accept(EditorCell cell) {
        return !((cell instanceof EditorCell_Collection)) && cell.getWidth() * cell.getHeight() != 0;
      }
    });
    Set<Integer> yCoordinatesSet = SetSequence.fromSetWithValues(new HashSet<Integer>(), Sequence.fromIterable(nonTrivialCells).select(new ISelector<EditorCell, Integer>() {
      public Integer select(EditorCell cell) {
        return cell.getY();
      }
    }));
    myPseudoLinesY = SetSequence.fromSet(yCoordinatesSet).sort(new ISelector<Integer, Integer>() {
      public Integer select(Integer y) {
        return y;
      }
    }, true).toListSequence();
    myEditorLineRecords = ListSequence.fromList(new ArrayList<AnnotationColumn.LineRevisionRecord>());
    ListSequence.fromList(myPseudoLinesY).visitAll(new IVisitor<Integer>() {
      public void visit(Integer t) {
        ListSequence.fromList(myEditorLineRecords).addElement(null);
      }
    });
    editor.getEditorContext().getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        // It seems the reason for model read is getPseudoLinedForContent->findCellForContent that deals with model of edited node 
        for (int fileLine = 0; fileLine < ListSequence.fromList(myFileLineToContent).count(); fileLine++) {
          LineContent lineContent = ListSequence.fromList(myFileLineToContent).getElement(fileLine);
          final VcsFileRevision fileLineRev = fileRevForLine(fileLine);
          if (fileLineRev == null) {
            // though it's odd, it happens that FileAnnotation.getLineRevisionNumber gives VcsRevisionNumber 
            // that has not been reported from FA.getRevisions().getRevisionNumber(), and the mapping is null 
            // FIXME figure out why is that and what one can do not to get empty lines in annotate 
            continue;
          }
          for (int pseudoLine : getPseudoLinesForContent(lineContent)) {
            final AnnotationColumn.LineRevisionRecord lr = ListSequence.fromList(myEditorLineRecords).getElement(pseudoLine);
            if (lr == null) {
              // XXX we might want to share same LRR instance for the group of editor lines, but then need to be careful 
              // when updating its actual revision 
              ListSequence.fromList(myEditorLineRecords).setElement(pseudoLine, new AnnotationColumn.LineRevisionRecord(lineContent.getNodeId(), fileLineRev, fileLine));
            } else {
              // we've got info for the editor line already, and it's attributed to some node and a revision 
              if (lr.nodeId.equals(lineContent.getNodeId())) {
                // same node is reported, but different revision, perhaps? Update if newer, keep previous otherwise 
                if (lr.rev.getRevisionDate().before(fileLineRev.getRevisionDate())) {
                  lr.rev = fileLineRev;
                  lr.fileLine = fileLine;
                }
              } else {
                // new node is reported for the line 
                // XXX it might be child of the original and therefore needs to take precedence over parent 
                //     or it might be parent again after child put its record earlier, replacing parent record 
                //     (keep in mind nested and closing tags <node parent><node child/></node parent>) 
                if (!(lr.isAmongPrevious(lineContent.getNodeId()))) {
                  // treat actual LineContent as more relevant and overwrite editor line record, yet keep knowledge about nodeid of the original record 
                  ListSequence.fromList(myEditorLineRecords).setElement(pseudoLine, new AnnotationColumn.LineRevisionRecord(lineContent.getNodeId(), fileLineRev, fileLine, lr));
                }
                // else this editor line has been recorded for the node of actual lineContent and later overwritten with another node 
                // assume that other node is more relevant (e.g. actual LineContent represents closing </node> tag of a parent node 
                // indeed, it's not necessarily true (we'd better record 'technical' lines like closing tag right in LineContent), but this heuristic is still better 
                // than 'just take the latest' approach 
              }
            }
          }
        }
      }
    });
    FontMetrics metrics = FontRegistry.getInstance().getFontMetrics(myFont);
    for (AnnotationAspectSubcolumn aspectSubcolumn : ListSequence.fromList(myAspectSubcolumns)) {
      aspectSubcolumn.computeWidth(metrics, ListSequence.fromList(myEditorLineRecords).where(new NotNullWhereFilter<AnnotationColumn.LineRevisionRecord>()));
    }
    mySubcolumnInterval = metrics.stringWidth(" ");
    calculateCurrentPseudoLinesLater();
  }
  @Override
  public String getTooltipText(MouseEvent event) {
    int fileLine = findFileLineByY(event.getY());
    if (fileLine == -1) {
      return null;
    } else {
      return myFileAnnotation.getToolTip(fileLine);
    }
  }
  @Nullable
  @Override
  public Cursor getCursor(MouseEvent event) {
    return (findFileLineByY(event.getY()) == -1 ? null : new Cursor(Cursor.HAND_CURSOR));
  }
  @Override
  public void mousePressed(MouseEvent event) {
    if (event.getButton() == MouseEvent.BUTTON1 && event.getID() == MouseEvent.MOUSE_RELEASED) {
      event.consume();
      int fileLine = findFileLineByY(event.getY());
      ((LineAnnotationAspectAdapter) myFileAnnotation.getAspects()[0]).doAction(fileLine);
    } else {
      super.mousePressed(event);
    }
  }
  @Override
  public void dispose() {
    myDiffRegistry.getCommandQueue().runTask(new Runnable() {
      public void run() {
        myDiffRegistry.getCurrentDifference(myModel).removeDifferenceListener(myDifferenceListener);
      }
    });
    myMessageBusConnection.disconnect();
    myFileAnnotation.dispose();
  }

  public void close() {
    getLeftEditorHighlighter().removeLeftColumn(this);
    dispose();
  }

  private int findPseudoLineByY(int y) {
    int pseudoLine = Collections.binarySearch((List) myPseudoLinesY, y);
    if (pseudoLine < 0) {
      pseudoLine = -pseudoLine - 2;
    }
    if (pseudoLine < 0 || pseudoLine >= ListSequence.fromList(myEditorLineRecords).count()) {
      return -1;
    }
    return pseudoLine;
  }
  private int findFileLineByY(int y) {
    int pseudoLine = findPseudoLineByY(y);
    if (pseudoLine == -1) {
      return -1;
    } else {
      if (SetSequence.fromSet(myCurrentPseudoLines).contains(pseudoLine)) {
        return -1;
      }
      return ListSequence.fromList(myEditorLineRecords).getElement(pseudoLine).fileLine;
    }
  }
  @Override
  public JPopupMenu getPopupMenu(MouseEvent event) {
    List<AnAction> actions = ListSequence.fromList(new ArrayList<AnAction>());
    final int fileLine = findFileLineByY(event.getY());
    ListSequence.fromList(actions).addElement(new BaseAction("Close Annotations") {
      @Override
      protected void doExecute(AnActionEvent e, Map<String, Object> _params) {
        close();
      }
    });
    ListSequence.fromList(actions).addElement(Separator.getInstance());
    ListSequence.fromList(actions).addElement(myViewActionGroup);
    if (fileLine != -1) {
      ListSequence.fromList(actions).addElement(new ShowDiffFromAnnotationAction(myFileAnnotation, fileLine, ListSequence.fromList(myFileLineToContent).getElement(fileLine)));
      ListSequence.fromList(actions).addElement(new BaseAction("Copy revision number") {
        @Override
        protected void doExecute(AnActionEvent e, Map<String, Object> params) {
          String asString = myFileAnnotation.getLineRevisionNumber(fileLine).asString();
          CopyPasteManager.getInstance().setContents(new TextTransferable(asString, asString));
        }
      });
    }
    ListSequence.fromList(actions).addElement(Separator.getInstance());
    ListSequence.fromList(actions).addElement(myRevisionRange);
    ListSequence.fromList(actions).addElement(new ShowAdditionalInfoAction(this));

    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(ListSequence.fromList(actions).toGenericArray(AnAction.class));
    return ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, actionGroup).getComponent();
  }
  private int getFileLineWithMaxRevision(int a, int b) {
    if (b == -1) {
      return a;
    }
    if (a == -1) {
      return b;
    }
    VcsRevisionNumber aRevision = myFileAnnotation.getLineRevisionNumber(a);
    VcsRevisionNumber bRevision = myFileAnnotation.getLineRevisionNumber(b);
    if (bRevision == null) {
      return a;
    }
    if (aRevision == null) {
      return b;
    }
    int c = aRevision.compareTo(bRevision);
    if (MapSequence.fromMap(myRevisionNumberToRevision).get(aRevision) != null && MapSequence.fromMap(myRevisionNumberToRevision).get(bRevision) != null) {
      c = MapSequence.fromMap(myRevisionNumberToRevision).get(aRevision).getRevisionDate().compareTo(MapSequence.fromMap(myRevisionNumberToRevision).get(bRevision).getRevisionDate());
    }
    if (c < 0) {
      return b;
    }
    return a;
  }
  public void invalidateLayout() {
    ApplicationManager.getApplication().invokeLater(new Runnable() {
      public void run() {
        getLeftEditorHighlighter().relayout(false);
      }
    });
  }
  public boolean isShowAdditionalInfo() {
    return myShowAdditionalInfo;
  }
  public void setShowAdditionalInfo(boolean showAdditionalInfo) {
    myShowAdditionalInfo = showAdditionalInfo;
    invalidateLayout();
  }

  /**
   * 
   * 
   * @return revisions from FileAnnotation, in the same order (from newest to oldest)
   */
  /*package*/ List<VcsFileRevision> getRevisions() {
    return myFileAnnotation.getRevisions();
  }

  /*package*/ Project getProject() {
    return myFileAnnotation.getProject();
  }

  private class MyDifferenceListener extends CurrentDifferenceAdapter {
    public MyDifferenceListener() {
    }
    @Override
    public void changeUpdateFinished() {
      calculateCurrentPseudoLinesLater();
    }
    @Override
    public void changeRemoved(@NotNull ModelChange change) {
      MapSequence.fromMap(myChangesToLineContents).removeKey(change);
    }
    @Override
    public void changeAdded(@NotNull ModelChange change) {
      saveChange(change);
    }
  }
  private class MyEditorComponentCreateListener implements EditorComponentCreateListener {
    public MyEditorComponentCreateListener() {
    }
    @Override
    public void editorComponentCreated(@NotNull EditorComponent ec) {
    }
    @Override
    public void editorComponentDisposed(@NotNull EditorComponent ec) {
      if (ec == getEditorComponent()) {
        close();
      }
    }
  }

  /*package*/ static class LineRevisionRecord {
    /*package*/ final SNodeId nodeId;

    /**
     * VcsFileRevision, not VcsRevisionNumber, as it gives both vcsRevNumber and author and facilitates ordering (VcsRevisionNumber.compareTo uses 
     * timestamp field which doesn't reflect revision date but rather the moment annotate was constructed)
     * Intentionally not final as it's updated if we find newer revision for the node
     */
    /*package*/ VcsFileRevision rev;
    /**
     * provisional, just to get legacy code that relies on file line number working
     * indicates file line where we picked rev from
     */
    /*package*/ int fileLine;
    private final List<SNodeId> prevRecordNodeId;

    /*package*/ LineRevisionRecord(SNodeId nid, VcsFileRevision n, int fileLineNumber) {
      nodeId = nid;
      rev = n;
      fileLine = fileLineNumber;
      prevRecordNodeId = null;
    }

    /*package*/ LineRevisionRecord(SNodeId nid, VcsFileRevision n, int fileLineNumber, AnnotationColumn.LineRevisionRecord prev) {
      nodeId = nid;
      rev = n;
      fileLine = fileLineNumber;
      prevRecordNodeId = ListSequence.fromList(new ArrayList<SNodeId>());
      ListSequence.fromList(prevRecordNodeId).addElement(prev.nodeId);
      if (ListSequence.fromList(prev.prevRecordNodeId).isNotEmpty()) {
        ListSequence.fromList(prevRecordNodeId).addSequence(ListSequence.fromList(prev.prevRecordNodeId));
      }
    }

    /*package*/ boolean isAmongPrevious(SNodeId nid) {
      return ListSequence.fromList(prevRecordNodeId).contains(nid);
    }
  }
  private static List<ModelChange> check_5mnya_a0a0a0a1a0a0o0w(ChangeSet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelChanges();
    }
    return null;
  }
}
