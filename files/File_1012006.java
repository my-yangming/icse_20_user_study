package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import jetbrains.mps.vfs.refresh.FileSystemListener;
import java.util.HashMap;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.ide.vfs.IdeaFileSystem;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import java.util.Set;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.fileTypes.MPSFileTypesManager;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.function.Function;
import com.intellij.openapi.util.io.FileUtil;
import jetbrains.mps.InternalFlag;
import jetbrains.mps.vfs.refresh.FileSystemEvent;
import java.util.HashSet;
import org.jetbrains.annotations.NotNull;
import java.util.Arrays;

/*package*/ class FileProcessor extends ReloadParticipant {
  private static final Logger LOG = LogManager.getLogger(FileProcessor.class);
  private final FileSystemListenersContainer myListenersContainer;
  private final Map<FileSystemListener, FileProcessor.ListenerData> myListener2Data = new HashMap<FileSystemListener, FileProcessor.ListenerData>();
  private final Queue<FileSystemListener> myPostNotify = QueueSequence.fromQueue(new LinkedList<FileSystemListener>());
  private final IdeaFileSystem FS;

  /*package*/ FileProcessor(IdeaFileSystem fs) {
    FS = fs;
    myListenersContainer = fs.getListenersContainer();
  }

  @Override
  public void update(ProgressMonitor monitor) {
    if (myListener2Data.isEmpty()) {
      return;
    }
    monitor.start("", myListener2Data.size() + 1);
    long updateStartTime = System.currentTimeMillis();
    try {
      // sorted according to #getListenerDependencies 
      Iterable<FileSystemListener> sortedListeners = sortedListeners();
      for (FileSystemListener listener : Sequence.fromIterable(sortedListeners)) {
        FileProcessor.ListenerData data = MapSequence.fromMap(myListener2Data).get(listener);
        if (!(myListenersContainer.contains(listener))) {
          monitor.advance(1);
          continue;
        }

        long listenerUpdateStartTime = System.currentTimeMillis();
        listener.update(monitor.subTask(1, SubProgressKind.AS_COMMENT), data);
        printStat("update:" + listener, listenerUpdateStartTime);
        data.isNotified = true;
      }
      long postNotifyBeginTime = System.currentTimeMillis();
      FileSystemListener listener;
      while ((listener = QueueSequence.fromQueue(myPostNotify).removeFirstElement()) != null) {
        FileProcessor.ListenerData data = myListener2Data.get(listener);
        if (data.isNotified) {
          continue;
        }
        listener.update(monitor.subTask(0, SubProgressKind.AS_COMMENT), data);
        data.isNotified = true;
      }
      printStat("post-notify", postNotifyBeginTime);
    } finally {
      printStat("update", updateStartTime);
      monitor.done();
    }
  }

  private void notify(FileSystemListener listener, FileProcessor.ListenerData source) {
    FileProcessor.ListenerData data = createNewDataIfAbsent(listener);
    if (!(data.isNotified)) {
      data.added.addAll(source.added);
      data.changed.addAll(source.changed);
      data.removed.addAll(source.removed);
      QueueSequence.fromQueue(myPostNotify).addLastElement(listener);
    }
  }

  private Iterable<FileSystemListener> sortedListeners() {
    Set<FileSystemListener> result = new LinkedHashSet<FileSystemListener>(myListener2Data.size());
    for (FileSystemListener l : SetSequence.fromSet(myListener2Data.keySet())) {
      visit(l, result);
    }
    return result;
  }

  private void visit(FileSystemListener listener, Set<FileSystemListener> result) {
    if (result.contains(listener)) {
      return;
    }
    result.add(listener);
    Iterable<FileSystemListener> dependencies = listener.getListenerDependencies();
    if (dependencies == null) {
      return;
    }

    boolean readd = false;
    for (FileSystemListener dep : dependencies) {
      if (myListener2Data.containsKey(dep) && !(result.contains(dep))) {
        visit(dep, result);
        readd = true;
      }
    }
    if (readd) {
      result.remove(listener);
      result.add(listener);
    }
  }

  /*package*/ boolean accepts(String path) {
    return !(MPSFileTypesManager.isFileIgnored(path));
  }

  /*package*/ void processDelete(String path) {
    final IFile file = FS.getFile(path);
    ListSequence.fromList(getData(file.getPath(), FileProcessor.EventKind.REMOVED)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.removed.add(file);
      }
    });
  }

  /*package*/ void processCreate(String path) {
    final IFile file = FS.getFile(path);
    ListSequence.fromList(getData(path, FileProcessor.EventKind.CREATED)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.added.add(file);
      }
    });
  }

  /*package*/ void processContentChanged(String path) {
    final IFile file = FS.getFile(path);
    ListSequence.fromList(getData(path, FileProcessor.EventKind.CONTENT_CHANGED)).visitAll(new IVisitor<FileProcessor.ListenerData>() {
      public void visit(FileProcessor.ListenerData it) {
        it.changed.add(file);
      }
    });
  }

  @Override
  public boolean isEmpty() {
    return myListener2Data.isEmpty();
  }

  public List<FileProcessor.ListenerData> getData(final String eventPath, final FileProcessor.EventKind kind) {
    FileSystemListenersContainer.ListenersForPath listeners = myListenersContainer.getListenersForPath(eventPath);
    Iterable<FileSystemListener> ancestors = ListSequence.fromList(listeners.ancestorListeners).where(new IWhereFilter<FileSystemListener>() {
      public boolean accept(FileSystemListener l) {
        return acceptAncestor(eventPath, l, kind);
      }
    });
    Iterable<FileSystemListener> concretePathListeners = listeners.concretePathListeners;
    Iterable<FileSystemListener> descendants = ListSequence.fromList(listeners.descendantsListeners).where(new IWhereFilter<FileSystemListener>() {
      public boolean accept(FileSystemListener l) {
        return acceptDescendant(eventPath, l, kind);
      }
    });
    List<FileSystemListener> allListeners = ListSequence.fromList(new ArrayList<FileSystemListener>());
    ListSequence.fromList(allListeners).addSequence(Sequence.fromIterable(ancestors));
    ListSequence.fromList(allListeners).addSequence(Sequence.fromIterable(concretePathListeners));
    ListSequence.fromList(allListeners).addSequence(Sequence.fromIterable(descendants));
    return ListSequence.fromList(allListeners).select(new ISelector<FileSystemListener, FileProcessor.ListenerData>() {
      public FileProcessor.ListenerData select(FileSystemListener listener) {
        return createNewDataIfAbsent(listener);
      }
    }).toListSequence();
  }

  private FileProcessor.ListenerData createNewDataIfAbsent(FileSystemListener listener) {
    return myListener2Data.computeIfAbsent(listener, new Function<FileSystemListener, FileProcessor.ListenerData>() {
      public FileProcessor.ListenerData apply(FileSystemListener it1) {
        return new FileProcessor.ListenerData();
      }
    });
  }

  private enum EventKind {
    REMOVED(),
    CREATED(),
    CONTENT_CHANGED()
  }


  private static boolean acceptDescendant(String eventPath, FileSystemListener listenerToChildFile, FileProcessor.EventKind kind) {
    IFile childFile = listenerToChildFile.getFileToListen();
    // contract to comment out later 
    assert FileUtil.startsWith(childFile.getPath(), eventPath) : "Contract is broken: " + childFile.getPath() + " does not start with " + eventPath;
    if (kind == FileProcessor.EventKind.CREATED && listenerToChildFile.listeningPreferences().notifyOnParentCreation) {
      return true;
    } else if (kind == FileProcessor.EventKind.CONTENT_CHANGED && listenerToChildFile.listeningPreferences().notifyOnParentChange) {
      return true;
    } else if (kind == FileProcessor.EventKind.REMOVED && listenerToChildFile.listeningPreferences().notifyOnParentRemoval) {
      return true;
    }
    return false;
  }

  private static boolean acceptAncestor(String eventPath, FileSystemListener listenerToParentFile, FileProcessor.EventKind kind) {
    IFile parentFile = listenerToParentFile.getFileToListen();
    // contract to comment out later 
    assert FileUtil.startsWith(eventPath, parentFile.getPath()) : "Contract is broken: " + eventPath + " does not start with " + parentFile.getPath();
    if (kind == FileProcessor.EventKind.CREATED && listenerToParentFile.listeningPreferences().notifyOnChildCreation) {
      return true;
    } else if (kind == FileProcessor.EventKind.CONTENT_CHANGED && listenerToParentFile.listeningPreferences().notifyOnChildChange) {
      return true;
    } else if (kind == FileProcessor.EventKind.REMOVED && listenerToParentFile.listeningPreferences().notifyOnChildRemoval) {
      return true;
    }
    return false;
  }

  private void printStat(String name, long beginTime) {
    if (InternalFlag.isInternalMode()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("FileProcessor: " + name + " -> " + (System.currentTimeMillis() - beginTime) / 1000.0 + "s");
      }
    }
  }

  private class ListenerData implements FileSystemEvent {
    private final Set<IFile> added = new HashSet<IFile>();
    private final Set<IFile> removed = new HashSet<IFile>();
    private final Set<IFile> changed = new HashSet<IFile>();
    private boolean isNotified;

    private ListenerData() {
    }

    @Override
    public Set<IFile> getCreated() {
      return added;
    }

    @Override
    public Set<IFile> getRemoved() {
      return removed;
    }

    @Override
    public Set<IFile> getChanged() {
      return changed;
    }

    @Override
    public void notify(FileSystemListener listener) {
      FileProcessor.this.notify(listener, this);
    }

    @Override
    public String toString() {
      return String.format("[added: %s; removed: %s; changed: %s.", setToString(added), setToString(removed), setToString(changed));
    }
  }

  @NotNull
  private static String setToString(Set<?> set) {
    return Arrays.toString(set.toArray());
  }

}
