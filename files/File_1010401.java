package jetbrains.mps.make.dependencies;

/*Generated by MPS */

import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.MakeSession;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class MakeSequence {
  private Iterable<Cluster> myClusters;
  private final Iterable<? extends IResource> myInputRes;
  private final IScript myDefaultScript;
  private final MakeSession myMakeSession;

  public MakeSequence(Iterable<? extends IResource> inputRes, @Nullable IScript defaultScript, @NotNull MakeSession makeSession) {
    myInputRes = inputRes;
    myDefaultScript = defaultScript;
    myMakeSession = makeSession;
    prepareClusters();
  }

  private void prepareClusters() {
    myMakeSession.getProject().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        ModulesClusterizer clusterizer = new ModulesClusterizer(myMakeSession);
        myClusters = clusterizer.clusterize(myInputRes);
      }
    });
  }

  private void prepareSciptForCluster(Cluster cluster) {
    if (myDefaultScript != null) {
      cluster.setScript(myDefaultScript);
    } else {
      ScriptBuilder builder = cluster.createScriptBuilder();
      cluster.setScript(myMakeSession.toScript(builder));
    }
  }

  public int steps() {
    return Sequence.fromIterable(myClusters).count();
  }

  public void iterate(_FunctionTypes._return_P2_E0<? extends Boolean, ? super IScript, ? super Iterable<IResource>> iterator) {
    // iterator accepts script and resources to be processed by the script, and returns false to stop 
    for (Cluster c : myClusters) {
      prepareSciptForCluster(c);
      if (!(iterator.invoke(c.getScript(), c.getResources()))) {
        break;
      }
    }
  }
}
