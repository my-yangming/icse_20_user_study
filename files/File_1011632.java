package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.iterable.RecursiveIterator;
import java.util.Iterator;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.build.mps.behavior.BuildMps_Generator__BehaviorDescriptor;
import org.jetbrains.annotations.NotNull;

public class MPSModulesClosure {
  /**
   * Language modules that have runtime : BuildMps_ModuleRuntime but not exactly BuildMps_ModuleSolutionRuntime
   */
  private final Set<SNode> myLanguagesWithOddRuntime = SetSequence.fromSet(new LinkedHashSet<SNode>());

  private final Set<SNode> myModules = SetSequence.fromSet(new LinkedHashSet<SNode>());
  private final Set<SNode> myDevkits = SetSequence.fromSet(new LinkedHashSet<SNode>());
  private final Iterable<SNode> myInitialModules;
  private final MPSModulesClosure.ModuleDependenciesOptions myOptions;

  public MPSModulesClosure(SNode initialModule, MPSModulesClosure.ModuleDependenciesOptions options) {
    myInitialModules = Sequence.<SNode>singleton(initialModule);
    myOptions = options;
  }

  public MPSModulesClosure(SNode initialModule) {
    this(initialModule, MPSModulesClosure.ModuleDependenciesOptions.DEFAULT);
  }

  public MPSModulesClosure(Iterable<SNode> initialModules, MPSModulesClosure.ModuleDependenciesOptions options) {
    myInitialModules = SNodeOperations.ofConcept(initialModules, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508331930cL, "jetbrains.mps.build.mps.structure.BuildMps_Module"));
    myOptions = options;
  }

  private Iterable<SNode> dependencies(SNode module) {
    return ListSequence.fromList(SLinkOperations.getChildren(module, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508331930cL, 0x48e82d5083341cb8L, "dependencies"))).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return (SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x64bd442e1cf7aaeeL, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency")) ? SLinkOperations.getTarget(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x64bd442e1cf7aaeeL, "jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency")), MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x64bd442e1cf7aaeeL, 0x64bd442e1cf7aaefL, "dependency")) : it);
      }
    });
  }

  private Iterable<SNode> getDependencies(SNode module, final boolean reexportOnly) {
    Iterable<SNode> dependencies = SLinkOperations.collect(Sequence.fromIterable(SNodeOperations.ofConcept(dependencies(module), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (!(reexportOnly) || SPropertyOperations.getBoolean(it, MetaAdapterFactory.getProperty(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, 0x48e82d5083341cc1L, "reexport")));
      }
    }), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, 0x48e82d5083341cb9L, "module"));

    // add extended langs 
    dependencies = Sequence.fromIterable(dependencies).concat(Sequence.fromIterable(SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(module), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x3b60c4a45c19032eL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x3b60c4a45c19032eL, 0x3b60c4a45c190330L, "language"))));

    if (reexportOnly) {
      return Sequence.fromIterable(dependencies).where(new NotNullWhereFilter<SNode>());
    }

    Iterable<SNode> usedDevkits = Sequence.fromIterable(includingExtended(dependencies_usedDevkits(module))).toListSequence();
    if (myOptions.myTrackDevkits) {
      SetSequence.fromSet(myDevkits).addSequence(Sequence.fromIterable(usedDevkits));
    }
    Iterable<SNode> solutionsFromDevkits = Sequence.fromIterable(usedDevkits).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.collect(SNodeOperations.ofConcept(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d2060eL, 0x4780308f5d29d82L, "exports")), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d29d7aL, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d29d7aL, 0x4780308f5d29d7bL, "solution"));
      }
    });
    // "core" language is added in loadModules pre-script 
    Iterable<SNode> distinct = IterableUtil.distinct(IterableUtil.merge(dependencies, solutionsFromDevkits));
    return Sequence.fromIterable(distinct).where(new NotNullWhereFilter<SNode>());
  }

  /**
   * also inlines used devkits
   */
  private Iterable<SNode> getUsedLanguagesWithExtended(SNode module) {
    Iterable<SNode> usedLangs = dependencies_usedLanguages(module);

    Iterable<SNode> usedDevkits = Sequence.fromIterable(includingExtended(dependencies_usedDevkits(module))).toListSequence();
    if (myOptions.doesTrackDevkits()) {
      SetSequence.fromSet(myDevkits).addSequence(Sequence.fromIterable(usedDevkits));
    }
    Iterable<SNode> languagesFromDevkits = Sequence.fromIterable(usedDevkits).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return SLinkOperations.collect(SNodeOperations.ofConcept(SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d2060eL, 0x4780308f5d29d82L, "exports")), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d29d6aL, "jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d29d6aL, 0x4780308f5d29d73L, "language"));
      }
    });

    // use "core" language is added in loadModules pre-script 
    return Sequence.fromIterable(includingExtendedLanguages(IterableUtil.merge(usedLangs, languagesFromDevkits))).where(new NotNullWhereFilter<SNode>());
  }

  private Iterable<SNode> dependencies_usedLanguages(SNode module) {
    return SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(module), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643d2d2L, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643d2d2L, 0x2c4467914643d2d3L, "language"));
  }

  private Iterable<SNode> dependencies_usedDevkits(SNode module) {
    return SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(module), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d5bc49L, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d5bc49L, 0x4780308f5d5bc4aL, "devkit"));
  }

  private static Iterable<SNode> includingExtended(Iterable<SNode> devkits) {
    return new RecursiveIterator<SNode>(devkits, false) {
      @Override
      protected Iterator<SNode> children(SNode node) {
        return Sequence.fromIterable(SLinkOperations.collect(SLinkOperations.getChildren(node, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d2060eL, 0x4780308f5d23142L, "extends")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4780308f5d2313aL, 0x4780308f5d2313bL, "devkit"))).iterator();
      }
    };
  }

  private Iterable<SNode> includingExtendedLanguages(Iterable<SNode> langs) {
    return new RecursiveIterator<SNode>(langs, false) {
      @Override
      protected Iterator<SNode> children(SNode node) {
        return Sequence.fromIterable(SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(node), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x3b60c4a45c19032eL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x3b60c4a45c19032eL, 0x3b60c4a45c190330L, "language"))).iterator();
      }
    };
  }

  private Iterable<SNode> usedGenerators(Iterable<SNode> generators) {
    return new RecursiveIterator<SNode>(generators, false) {
      protected Iterator<SNode> children(SNode generator) {
        return Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(generator), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, 0x48e82d5083341cb9L, "module")), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4c6db07d2e56a8b4L, "jetbrains.mps.build.mps.structure.BuildMps_Generator"))).iterator();
      }
    };
  }

  private void collectDependencies(Iterable<SNode> modules, boolean reexportOnly) {
    if (Sequence.fromIterable(modules).isEmpty()) {
      return;
    }
    Set<SNode> dependencies = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode module : Sequence.fromIterable(modules)) {
      SetSequence.fromSet(dependencies).addSequence(Sequence.fromIterable(getDependencies(module, reexportOnly)));
    }
    SetSequence.fromSet(dependencies).removeSequence(SetSequence.fromSet(myModules));
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(dependencies));
    collectDependencies(dependencies, reexportOnly);
  }

  /**
   * For each module, collect execution-time dependencies, based on runtime solution of languages which were used to
   * generate given module. Dependencies are transitive (i.e. include RTs for runtime solutions). 
   * 
   * Dependencies necessary to load RT solutions are also included. For an input module, DOES NOT include dependencies other than RT solutions.
   * 
   * @param sequence input modules
   */
  private void collectAllUsedLanguageRuntimesAndTheirDeps(Iterable<SNode> sequence) {
    if (Sequence.fromIterable(sequence).isEmpty()) {
      return;
    }
    Set<SNode> langs = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> langsWithOddRT = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> rtSolutions = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode module : Sequence.fromIterable(sequence)) {
      fillUsedLanguageRuntimes(module, langs, langsWithOddRT, rtSolutions);
    }
    SetSequence.fromSet(rtSolutions).removeSequence(SetSequence.fromSet(myModules));
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(rtSolutions));
    SetSequence.fromSet(myLanguagesWithOddRuntime).addSequence(SetSequence.fromSet(langsWithOddRT));
    collectDependencies((Iterable<SNode>) rtSolutions, false);
    collectAllUsedLanguageRuntimesAndTheirDeps((Iterable<SNode>) rtSolutions);
  }

  private void collectGeneratorsDependendencies(Iterable<SNode> languages) {
    if (Sequence.fromIterable(languages).isEmpty()) {
      return;
    }

    List<SNode> queue = new ArrayList<SNode>();
    ListSequence.fromList(queue).addSequence(Sequence.fromIterable(languages));

    Set<SNode> visitedLanguages = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> extraModules = SetSequence.fromSet(new HashSet<SNode>());

    while (ListSequence.fromList(queue).isNotEmpty()) {
      SNode nextLang = ListSequence.fromList(queue).removeElementAt(0);
      if (SetSequence.fromSet(visitedLanguages).contains(nextLang)) {
        continue;
      }
      SetSequence.fromSet(visitedLanguages).addElement(nextLang);

      // MPS-25255, modules of language's accessory models, if not hosted by language itself 
      SetSequence.fromSet(extraModules).addSequence(Sequence.fromIterable(SLinkOperations.collect(SLinkOperations.getChildren(nextLang, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f8L, 0x6e2dd2f4c4c3e91dL, "accessory")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x6e2dd2f4c4c3e91aL, 0x6e2dd2f4c4c3e91bL, "module"))));

      SNode g = SLinkOperations.getTarget(nextLang, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f8L, 0x7fae147806433827L, "generator"));
      if (g == null) {
        continue;
      }
      Iterable<SNode> deps = SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(g), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508334b11aL, 0x48e82d5083341cb9L, "module"));
      Iterable<SNode> usedLangs = SLinkOperations.collect(SNodeOperations.ofConcept(dependencies(g), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643d2d2L, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643d2d2L, 0x2c4467914643d2d3L, "language"));

      // I'm not quite sure it's possible to depend directly from generator module. 
      // Instead introduce a dependency from generator's source language 
      ListSequence.fromList(queue).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(deps, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x4c6db07d2e56a8b4L, "jetbrains.mps.build.mps.structure.BuildMps_Generator"))).select(new ISelector<SNode, SNode>() {
        public SNode select(SNode it) {
          return (SNode) BuildMps_Generator__BehaviorDescriptor.getSourceLanguage_id7YI57w6ZMdZ.invoke(it);
        }
      }).where(new NotNullWhereFilter<SNode>()));
      ListSequence.fromList(queue).addSequence(Sequence.fromIterable(usedLangs));
      // If a generator depends on any language module, it doesn't mean it's 'used language', it's merely a module dependency, therefore we don't pit it into queue and do not process 
      // any further but as a regular module dependency. In fact, it seems reasonable just to have addAll(deps) here, without filtering languages and solutions (just need to make clear 
      // what could possibly dependencies to devkit and generator modules mean) 
      SetSequence.fromSet(extraModules).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(deps, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f8L, "jetbrains.mps.build.mps.structure.BuildMps_Language"))));
      SetSequence.fromSet(extraModules).addSequence(Sequence.fromIterable(SNodeOperations.ofConcept(deps, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f7L, "jetbrains.mps.build.mps.structure.BuildMps_Solution"))));
    }
    SetSequence.fromSet(visitedLanguages).removeSequence(SetSequence.fromSet(myModules));
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(visitedLanguages));
    SetSequence.fromSet(extraModules).removeSequence(SetSequence.fromSet(myModules));
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(extraModules));
  }

  /**
   * Modules one needs to compile the generated sources of initial modules
   * To compile, module needs its direct dependencies, plus re-exported dependencies of those.
   * RTs of used languages and their dependencies won't hurt either.
   */
  public MPSModulesClosure closure() {
    // get all direct dependencies abd runtimes, plus re-exported dependencies thereof. 
    Set<SNode> langs = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> langsWithOddRT = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> solutions = SetSequence.fromSet(new HashSet<SNode>());

    for (SNode module : Sequence.fromIterable(myInitialModules)) {
      List<SNode> firstLevelDeps = Sequence.fromIterable(getDependencies(module, false)).toListSequence();
      collectDependencies(firstLevelDeps, true);
      fillUsedLanguageRuntimes(module, langs, langsWithOddRT, solutions);
      SetSequence.fromSet(myModules).addSequence(ListSequence.fromList(firstLevelDeps));
    }
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(solutions));
    SetSequence.fromSet(myLanguagesWithOddRuntime).addSequence(SetSequence.fromSet(langsWithOddRT));
    collectDependencies((Iterable<SNode>) solutions, true);
    if (!(myOptions.doesIncludeInitial())) {
      SetSequence.fromSet(myModules).removeSequence(Sequence.fromIterable(myInitialModules).toListSequence());
    }
    return this;
  }

  /**
   * The dependencies one needs to run the generated sources of the initial modules
   * To start, module needs all its dependencies plus RTs of languages it uses.
   * However, its use in mps.build.mps generator is dubious, as it merely adds rt dependencies of specific module
   * to the list of external (for the current project) modules.
   * 
   * Its use in MPSModulesPartitioner is another way of saying "if I generate a model and there's a language, which has runtime coming from another build script, add it to dependencies"
   * Although it's not clear why would one need language runtime during generation.
   * XXX Perhaps, {@link jetbrains.mps.build.mps.util.MPSModulesClosure#generationDependenciesClosure() } shall collect module's dependencies (collectDependencies(false)) instead
   * XXX There's {@link jetbrains.mps.build.mps.util.RuntimeDependencies } that builds a set of dependencies we record in deployment MD (extracted from this class), perhaps, could refactor both classes to reuse knowledge?
   */
  public MPSModulesClosure runtimeClosure() {
    SetSequence.fromSet(myModules).addSequence(Sequence.fromIterable(myInitialModules));
    collectDependencies(myInitialModules, false);
    collectAllUsedLanguageRuntimesAndTheirDeps(myModules);
    if (!(myOptions.doesIncludeInitial())) {
      SetSequence.fromSet(myModules).removeSequence(Sequence.fromIterable(myInitialModules).toListSequence());
    }
    return this;
  }

  /**
   * Modules we need to load in order for initial modules to be designed.
   * Looks like an attempt to replace MPSModulePartitioner.getExternal() + runtimeClosure() (i.e. expand external dependencies with dependencies from this project)
   * We use this to populate libraries of Environment for our tasks (MpsWorker) to start MPS with specific set of modules (hence we need a closure of modules for MPS to start properly).
   */
  public MPSModulesClosure designtimeClosure() {
    // rt deps -- direct and indirect dependencies of the modules, used languages and their runtimes 
    MPSModulesClosure rtClosure = new MPSModulesClosure(myInitialModules, new MPSModulesClosure.ModuleDependenciesOptions(myOptions).setIncludeInitial()).runtimeClosure();
    mergeIntoMe(rtClosure);

    // used languages must be deployable 
    List<SNode> copyOfMyModules = ListSequence.fromListWithValues(new ArrayList<SNode>(), myModules);
    for (SNode module : ListSequence.fromList(copyOfMyModules)) {
      Iterable<SNode> usedLanguages = getUsedLanguagesWithExtended(module);
      SetSequence.fromSet(myModules).addSequence(Sequence.fromIterable(usedLanguages).toListSequence());
      MPSModulesClosure rtClosureOfUsedLangs = new MPSModulesClosure(usedLanguages, new MPSModulesClosure.ModuleDependenciesOptions(myOptions).setIncludeInitial()).runtimeClosure();
      mergeIntoMe(rtClosureOfUsedLangs);
    }
    if (!(myOptions.doesIncludeInitial())) {
      SetSequence.fromSet(myModules).removeSequence(Sequence.fromIterable(myInitialModules).toListSequence());
    }
    return this;
  }

  /**
   * myInitialModules stay intact
   */
  private void mergeIntoMe(@NotNull MPSModulesClosure anotherClosure) {
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(anotherClosure.myModules));
    SetSequence.fromSet(myLanguagesWithOddRuntime).addSequence(SetSequence.fromSet(anotherClosure.myLanguagesWithOddRuntime));
    SetSequence.fromSet(myDevkits).addSequence(SetSequence.fromSet(anotherClosure.myDevkits));
  }

  /**
   * The modules we need to generate the initial modules
   * To generate a module, we need its languages and all their dependencies.
   * Since we assume that the generator might address any aspect of input language during the generation procedure
   * we unclude all the runtime dependencies of used languages into the result as well.
   * Unlike {@link jetbrains.mps.build.mps.util.MPSModulesClosure#runtimeClosure() } or {@link jetbrains.mps.build.mps.util.MPSModulesClosure#designtimeClosure() }, dependencies of the module itself (aka classpath) doesn't look
   * that important (although what if there's utility class in the generator, which depends on external module, and is queried during generation?)
   * todo: Generator's dependencies obviously must be considered separately
   */
  public MPSModulesClosure generationDependenciesClosure() {
    // direct and indirect dependencies of used languages and their runtimes; source languages of generators involved 
    Set<SNode> usedLanguages = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> langsWithOddRT = SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> solutions = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode m : Sequence.fromIterable(myInitialModules)) {
      fillUsedLanguageRuntimes(m, usedLanguages, langsWithOddRT, solutions);
    }
    // need module of a used language AND anything this module would require to load 
    collectDependencies((Iterable<SNode>) usedLanguages, false);
    collectAllUsedLanguageRuntimesAndTheirDeps((Iterable<SNode>) usedLanguages);
    // code, generated with a used language, might require runtime of the language, and anything this RT solution 
    // re-exports. However, without all dependencies (including non-reexported), solution won't load, hence include all. 
    collectDependencies((Iterable<SNode>) solutions, false);
    // RT solutions might be generated with other set of languages with own set of RT dependencies, collect these, too. 
    collectAllUsedLanguageRuntimesAndTheirDeps((Iterable<SNode>) solutions);
    // for employed languages, look at their generators and include their dependencies, too 
    collectGeneratorsDependendencies(usedLanguages);
    SetSequence.fromSet(myModules).addSequence(SetSequence.fromSet(usedLanguages));
    SetSequence.fromSet(myLanguagesWithOddRuntime).addSequence(SetSequence.fromSet(langsWithOddRT));
    if (!(myOptions.doesIncludeInitial())) {
      SetSequence.fromSet(myModules).removeSequence(Sequence.fromIterable(myInitialModules).toListSequence());
    }
    return this;
  }

  /**
   * Collects and analyzes used languages and their runtime solutions for the given module.
   * Generally, shall be static and without side-effects, however, at the moment uses {@link jetbrains.mps.build.mps.util.MPSModulesClosure#getUsedLanguagesWithExtended(SNode) } which updates myDevkits field
   * FIXME refactor, introduce fillUsedLanguages(module, set[languages])and make them static
   * 
   * @param module given
   * @param usedLanguages filled with used languages of the module
   * @param languagesWithRuntime will be filled with the used languages that has runtime which IS NOT a regular runtime solution
   * @param runtimeSolutions filled with runtime solutions found for used languages
   */
  private void fillUsedLanguageRuntimes(SNode module, Set<SNode> usedLanguages, Set<SNode> languagesWithRuntime, Set<SNode> runtimeSolutions) {
    List<SNode> ul = Sequence.fromIterable(getUsedLanguagesWithExtended(module)).toListSequence();
    SetSequence.fromSet(usedLanguages).addSequence(ListSequence.fromList(ul));
    for (SNode language : ul) {
      boolean hasRuntime = false;
      for (SNode rdep : SLinkOperations.getChildren(language, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c446791464290f8L, 0x2c4467914643be24L, "runtime"))) {
        if (!(SNodeOperations.isInstanceOf(rdep, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914644b6e3L, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime")))) {
          hasRuntime = true;
          continue;
        }
        SNode runtimeSolution = SLinkOperations.getTarget(SNodeOperations.cast(rdep, MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914644b6e3L, "jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914644b6e3L, 0x2c4467914644b6e4L, "solution"));
        if (runtimeSolution != null) {
          SetSequence.fromSet(runtimeSolutions).addElement(runtimeSolution);
        }
      }
      if (hasRuntime) {
        SetSequence.fromSet(languagesWithRuntime).addElement(language);
      }
    }
  }

  public MPSModulesClosure.RequiredJavaModules getRequiredJava() {
    Iterable<SNode> reexportedFromModuleDependencies = SLinkOperations.collect(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.collectMany(Sequence.fromIterable(getModules()).concat(Sequence.fromIterable(myInitialModules)), MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508331930cL, 0x48e82d5083341cb8L, "dependencies")), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643e8fbL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getBoolean(it, MetaAdapterFactory.getProperty(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643e8fbL, 0x2c4467914643e8fcL, "reexport"));
      }
    }), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643e8fbL, 0x2c4467914643e8fdL, "module"));
    Set<SNode> reexportMods = SetSequence.fromSet(new HashSet<SNode>());
    for (SNode mod : reexportedFromModuleDependencies) {
      SetSequence.fromSet(reexportMods).addElement(mod);
    }

    Iterable<SNode> directDeps = SLinkOperations.collect(SNodeOperations.ofConcept(SLinkOperations.collectMany(myInitialModules, MetaAdapterFactory.getContainmentLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x48e82d508331930cL, 0x48e82d5083341cb8L, "dependencies")), MetaAdapterFactory.getConcept(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643e8fbL, "jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnJavaModule")), MetaAdapterFactory.getReferenceLink(0xcf935df46994e9cL, 0xa132fa109541cba3L, 0x2c4467914643e8fbL, 0x2c4467914643e8fdL, "module"));
    return new MPSModulesClosure.RequiredJavaModules(Sequence.fromIterable(reexportedFromModuleDependencies).concat(Sequence.fromIterable(directDeps)), reexportMods);
  }

  /**
   * to be deprecated
   * use the one below
   */
  public Iterable<SNode> getModules() {
    return myModules;
  }

  /**
   * great job having these two methods together
   * seems that unlike the #getModules this one returns devkits as well (odd considering we provide options at the initialization of the MMC) +
   * the languages with runtime solution which is not instance of BuildMps_ModuleRuntime
   * I suggest using this method by default and not using the one above
   * 
   * fixme merge and use the same method everywhere
   */
  public Iterable<SNode> getAllModules() {
    return Sequence.fromIterable(((Iterable<SNode>) myModules)).concat(Sequence.fromIterable((Iterable<SNode>) myLanguagesWithOddRuntime)).concat(Sequence.fromIterable((Iterable<SNode>) myDevkits));
  }

  public SNode getInitial() {
    return Sequence.fromIterable(myInitialModules).first();
  }

  public static class RequiredJavaModules {
    private Iterable<SNode> modules;
    private Set<SNode> reexported;

    public RequiredJavaModules(Iterable<SNode> modules, Set<SNode> reexported) {
      this.modules = modules;
      this.reexported = reexported;
    }

    public Iterable<SNode> getModules() {
      return modules;
    }

    public boolean isReexported(SNode mod) {
      return SetSequence.fromSet(reexported).contains(mod);
    }
  }

  public static class ModuleDependenciesOptions {
    public static final MPSModulesClosure.ModuleDependenciesOptions DEFAULT = new MPSModulesClosure.ModuleDependenciesOptions();
    private boolean myTrackDevkits = false;
    private boolean myIncludeInitial = false;

    public ModuleDependenciesOptions() {
    }

    public ModuleDependenciesOptions(@NotNull MPSModulesClosure.ModuleDependenciesOptions copyFrom) {
      myTrackDevkits = copyFrom.myTrackDevkits;
      myIncludeInitial = copyFrom.myIncludeInitial;
    }

    public MPSModulesClosure.ModuleDependenciesOptions setTrackDevkits() {
      myTrackDevkits = true;
      return this;
    }

    public MPSModulesClosure.ModuleDependenciesOptions setIncludeInitial() {
      myIncludeInitial = true;
      return this;
    }

    /**
     * if false then each devkit will be inlined (meaning the devkit modules themselves will not be included in any closure
     */
    public boolean doesTrackDevkits() {
      return myTrackDevkits;
    }

    /**
     * if true then initial modules are included into all the closures. (to be honest 'does include' = 'does not exclude' here)
     * by default it is false
     */
    public boolean doesIncludeInitial() {
      return myIncludeInitial;
    }
  }
}
