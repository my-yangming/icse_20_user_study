package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.FilteringScope;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.util.Pair;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.scope.ModelPlusImportedScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;

public class ClassifiersScope extends FilteringScope {
  private final boolean myIncludeAncestors;
  private final SNode myClassifier;
  private final Map<Pair<SNode, String>, SNode> myResolveCache = new HashMap<Pair<SNode, String>, SNode>();
  private final Set<Pair<SNode, String>> myResolveFailed = new HashSet<Pair<SNode, String>>();

  /**
   * 
   * @param model we respect classifiers from this model and from models imported into it
   * @param clas context classifier
   * @param concept shall be a Classifier or its subconcept
   * @param includeAncestors {@code false} indicates we ignore first Classifier ancestor of a context node from {@link #resolve(SNode, String) method. Generally, it's handy for links like extends/implements.
   */
  public ClassifiersScope(SModel model, SNode clas, SAbstractConcept concept, boolean includeAncestors) {
    super(new ModelPlusImportedScope(model, false, concept));
    // Another important aspect of includeAncestors is scope for dynamic references 
    // Imagine we need a scope for 'implements' reference of a ClassConcept. If we includeAncestors == true, then 
    //   the moment ClassifierResolveUtils.resolve() later tries to build ancestors, it would end up with the need to follow 
    //   'implements' reference of the class again, and we face a loop 
    myIncludeAncestors = includeAncestors;
    myClassifier = clas;
  }

  public ClassifiersScope(SModel model, SNode clas, SAbstractConcept concept) {
    this(model, clas, concept, false);
  }

  @Override
  public boolean isExcluded(SNode node) {
    return SNodeOperations.isInstanceOf(node, SNodeOperations.asSConcept(ClassifierResolveUtils.anonymousClassConcept));
  }

  @Override
  public SNode resolve(SNode contextNode, String refText) {
    SModel contextModel = SNodeOperations.getModel(contextNode);
    if (contextModel == null) {
      // I see no legitimate reason to proceed any further. 
      // Generally, I don't expect this guard condition to ever trigger, as it's odd to access references of a detached node. 
      // However, with MPS, you never know. 
      return null;
    }
    SNode contextClassifier = SNodeOperations.getNodeAncestor(contextNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), true, false);

    // scopes were never advertised as capable of/demanding to multi-thread, hence regular map. 
    // Though we may cache resolved references at ReferenceScopeHelper level, it doesn't know proper 'caching scope', like use of ancestor Classifier here. 

    // all references to classes within same class share context, hence cache per closest Classifier ancestor, if any 
    // However, it's not of great help now as Scope instances are cached per SReference (i.e. with its source node), hence it's unlikely 
    // we get into same scope instance for the same contextClassifier. 

    // we tolerate contextClassifier == null just for the sake of refText.startWith([) scenario, which I'd like to have cached anyway 
    final Pair<SNode, String> key = new Pair<SNode, String>((contextClassifier == null ? contextNode : contextClassifier), refText);
    SNode cached = myResolveCache.get(key);
    if (cached == null) {
      if (myResolveFailed.contains(key)) {
        return null;
      }
      cached = resolveImpl(contextModel, contextClassifier, refText);
      if (cached == null) {
        myResolveFailed.add(key);
      } else {
        myResolveCache.put(key, cached);
      }
    }
    return cached;
  }

  private SNode resolveImpl(SModel contextModel, @Nullable SNode contextClassifier, String refText) {
    // hack for [model]node construction, remove it 
    if (refText.indexOf('[') == 0) {
      return ClassifierResolveUtils.resolveSpecialSyntax(refText, contextModel);
    }
    // end of hack 
    // TODO Must be done through ScopeProvider 
    // 
    if ((contextClassifier == null)) {
      // no class outside, just use simple old logic 
      return ClassifierResolveUtils.resolveNonSpecialSyntax(refText, contextModel, (ModelPlusImportedScope) wrapped);
    }
    SNode resolved = ClassifierResolveUtils.resolve(refText, contextClassifier, myIncludeAncestors);

    if (resolved != null) {
      return resolved;
    }
    // try to use old logic 
    return ClassifierResolveUtils.resolveNonSpecialSyntax(refText, contextModel, (ModelPlusImportedScope) wrapped);
  }

  @Override
  public boolean contains(SNode node) {
    if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
      return false;
    }
    if (super.contains(node)) {
      return true;
    }

    SNode root = Sequence.fromIterable(ClassifierResolveUtils.getPathToRoot(myClassifier)).last();
    if ((root != null) && (AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))) != null)) {
      return ClassifierResolveUtils.isImportedBy(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))));
    }

    return false;
  }
}
