package jetbrains.mps.tool.environment;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import jetbrains.mps.tool.common.PluginData;
import java.io.File;
import java.util.List;
import java.util.regex.Matcher;
import org.apache.log4j.Level;
import java.io.FileReader;
import java.nio.CharBuffer;
import java.util.Collection;
import java.util.Collections;
import org.jetbrains.annotations.Nullable;
import java.util.ArrayList;
import jetbrains.mps.core.tool.environment.common.StringUtil;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.URLClassLoader;

/**
 * Deals with (idea) platform plugins for the purposes of MpsEnvironment.
 * When there's full-fledged IDEA (i.e. IdeaEnvironment), there's no need to process plugin.xml, but with lightweight MpsEnvironment we have to carry the burden
 * This is basically what PluginManagerCore from IDEA platform does, stripped down and focused on vital aspects only (namely, classloading and discovery of MPS modules)
 */
/*package*/ class PlatformPlugins {
  private static final Logger LOG = LogManager.getLogger(PlatformPlugins.class);
  public static final String PLUGIN_DESCRIPTOR_LOCATION = "META-INF/plugin.xml";

  private final Map<String, PlatformPlugins.Descriptor> myPlugins = new HashMap<String, PlatformPlugins.Descriptor>();
  private final Map<String, ClassLoader> myLoaders = new HashMap<String, ClassLoader>();
  private final Pattern myPluginIdPattern = Pattern.compile("<id>([a-zA-Z_0-9.]+)</id>");


  /*package*/ PlatformPlugins(EnvironmentConfig config) {
    // FIXME PathManager.getPluginsPath is a dependency to j.m.tool.common I'd like to get rid of (this class has access to MPS kernel classes 
    //       and doesn't need to depend from tool.common at all), but I didn't find a proper alternative. Alex P., could you please help me here? 
    for (PluginData pd : config.getPlugins()) {
      File pluginLocation = new File(pd.path);
      List<File> cp = detectClasspath(pluginLocation);
      List<File> langLibs = detectLanguageLibraries(pluginLocation);
      final CharSequence pluginXmlContent = readFile(new File(pluginLocation, PLUGIN_DESCRIPTOR_LOCATION), 4096);
      final Matcher idMatcher = myPluginIdPattern.matcher(pluginXmlContent);
      final String detectedId = (idMatcher.find() ? idMatcher.group(1) : null);
      final String pluginId;
      if (pd.id != null && !(pd.id.isEmpty())) {
        if (detectedId == null) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(String.format("Could not verify id of plugin %s from %s", pd.id, pluginLocation));
          }
          pluginId = pd.id;
        } else {
          if (!(pd.id.equals(detectedId))) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error(String.format("Plugin %s has been detected as %s but claims to be %s. Resort to detected value.", pluginLocation, detectedId, pd.id));
            }
          }
          pluginId = detectedId;
        }
      } else {
        if (detectedId != null) {
          // regular scenario, when <plugin> has path only and no id (e.g. <generate> task), use the one from plugin.xml 
          pluginId = detectedId;
        } else {
          // use uniqie value not to overwrite map entries 
          pluginId = String.format("plugin.%x", System.identityHashCode(pd));
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn(String.format("Could not detect id for plugin at %s", pluginLocation));
          }
        }
      }

      // XXX detect dependencies from other plugins to create proper classloading dependencies,  match <depends></depends> much like plugin id, above 
      //     meanwhile, hope there's no plugin code that references classes from its dependencies. 
      PlatformPlugins.Descriptor d = new PlatformPlugins.Descriptor(pluginId, pluginLocation, cp, langLibs);
      myPlugins.put(pluginId, d);
      if (LOG.isDebugEnabled()) {
        LOG.debug(String.format("Discovered %s; cp=%s, modules=%s", d, cp, langLibs));
      }
    }
  }

  private static CharSequence readFile(File f, int howMuch) {
    FileReader reader = null;
    try {
      reader = new FileReader(f);
      CharBuffer cb = CharBuffer.allocate(howMuch);
      reader.read(cb);
      cb.flip();
      return cb;
    } catch (Exception ex) {
      // ignore 
    } finally {
      try {
        if (reader != null) {
          reader.close();
        }
      } catch (Exception ex) {
        // ignore 
      }
    }
    return "";
  }


  /*package*/ boolean isEmpty() {
    return myPlugins.isEmpty();
  }

  /*package*/ void buildClassLoaders(ClassLoader rootClassLoader) {
    for (PlatformPlugins.Descriptor pd : myPlugins.values()) {
      ClassLoader cl = createPluginClassLoader(pd, rootClassLoader);
      myLoaders.put(pd.id, cl);
    }
  }

  /*package*/ Collection<PlatformPlugins.Descriptor> found() {
    //  provisional method, just to move forward. I indend to hide implementation structures from the outer world eventually. 
    return Collections.<PlatformPlugins.Descriptor>unmodifiableCollection(myPlugins.values());
  }

  @Nullable
  /*package*/ ClassLoader pluginClassLoader(String id) {
    return myLoaders.get(id);
  }

  private List<File> detectClasspath(File pluginLocation) {
    // copied from IdeaPluginDescriptorImpl.getClassPath() to match cp in either base platform 
    // even that we don't support .zip-bundled plugins (!isDirectory branch) 
    if (pluginLocation.isDirectory()) {
      final List<File> result = new ArrayList<File>();
      final File classesDir = new File(pluginLocation, "classes");
      if (classesDir.exists()) {
        result.add(classesDir);
      }
      final File[] files = new File(pluginLocation, "lib").listFiles();
      if (files != null && files.length > 0) {
        for (final File f : files) {
          if (f.isFile()) {
            final String name = f.getName();
            if (StringUtil.endsWithIgnoreCase(name, ".jar") || StringUtil.endsWithIgnoreCase(name, ".zip")) {
              result.add(f);
            }
          } else {
            result.add(f);
          }
        }
      }
      return result;
    } else {
      return Collections.singletonList(pluginLocation);
    }
  }

  private List<File> detectLanguageLibraries(File pluginLocation) {
    // unless we parse plugin.xml to read actual mps.LanguageLibrary extpoint, use hardcoded locations for mps modules distributed in plugins 
    ArrayList<File> rv = new ArrayList<File>(3);
    // in most cases it's "languages" (LL dir="/" value is often the same as "languages", I didn't find a plugin to put modules under root 
    // but e.g. mps-build uses both "solutions" and "pluginSolutions", projectMigrations uses "solution" 
    for (String loc : new String[]{"languages", "solutions", "pluginSolutions", "solution"}) {
      File f = new File(pluginLocation, loc);
      if (f.exists()) {
        rv.add(f);
      }
    }
    return (rv.isEmpty() ? Collections.<File>emptyList() : rv);
  }

  private static ClassLoader createPluginClassLoader(PlatformPlugins.Descriptor pd, ClassLoader rootCL) {
    if (pd.cp.isEmpty()) {
      return rootCL;
    }
    List<URL> urls = new ArrayList<URL>(pd.cp.size());
    for (File libjar : pd.cp) {
      try {
        urls.add(libjar.toURI().toURL());
      } catch (MalformedURLException ignored) {
      }
    }
    // XXX classloader relations are tricky, given that there might be few <plugin> tags along with few <library> tags 
    //     in a single task: without IDEA, how does dependencies between two different <plugin> work? If there's shared 
    //     classloader (global classpath), then myRootClassLoader has to represent one. If classloader is distinct per plugin, 
    //     we would need to manage dependencies here, take them into account and do not use myRootClassLoader here. 
    //     As for <library>-specified modules, what if it points to a module coming from a plugin with a dependency to the 
    //     sibling <plugin>? This is not necessarily 'proper' scenario, as we should use <plugin> rather than <library> in this case, 
    //     but alas mps.build language has its own perspective (the point is, can not control that). Again, for shared classpath 
    //     it's ok to reference this global CL here with myRootClassLoader. If one day plugins get distinct CL, then we would need to 
    //     decide whether a <library> specified module may depend on classes available from <plugin> (note, dependency on a module 
    //     distributed with <plugin> is fine, as the latter would get proper plugin CL as a fallback. Does scenario that concerns me 
    //     here, with <library> dependency on <plugin> CLASSPATH, relevant at all?) 
    // FIXME the funny thing about plugin CL here is that at the moment we collect plugin CP with all the libraries into global 
    //       classpath and we could use myRootClassLoader right away. Moreover, CL built here is plain wrong for IdeaEnvironment case 
    //       as <plugin>/lib/ classses are already available in the global CP and it's odd to expose them again for SLibrary's fallback CL. 
    //       What saves us here is the fact ClassLoader consults parent CL first and finds the classes there. 
    //       I keep it this way just for the record, and as a reference for future implementation if I decide to use distinct plugin 
    //       classloaders after all. 
    // Here used to be outdated copy of IDEA's UrlClassLoader, with uncertain benefits over standard Java's one. 
    // I don't think there's anything wrong with java.net counterpart. The only issue I'm aware of, http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5041014 
    // is not important in a scenario we use MpsEnvironment for. Besides, there's #close() method now we may use to address the issue in case we ever face it. 
    return new URLClassLoader(urls.toArray(new URL[urls.size()]), rootCL);
  }

  /**
   * fields are never null, lists could be empty, files reference existing locations
   */
  /*package*/ class Descriptor {
    public final String id;
    public final File home;
    public final List<File> cp;
    public final List<File> modules;

    /*package*/ Descriptor(String pid, File pluginLocation, List<File> classpath, List<File> languageLibs) {
      id = pid;
      home = pluginLocation;
      cp = classpath;
      modules = languageLibs;
    }

    /*package*/ ClassLoader classLoader() {
      return pluginClassLoader(id);
    }

    @Override
    public String toString() {
      return String.format("[%s @ %s]", id, home);
    }
  }
}
