package jetbrains.mps.tool.common;

/*Generated by MPS */

import org.apache.log4j.Level;
import java.util.Map;
import java.util.LinkedHashMap;
import java.io.File;
import java.util.List;
import java.util.ArrayList;
import org.jdom.Element;

/**
 * Keeps properties necessary to start an MPS instance and to execute a worker class within this new instance. 
 * Primary purpose is to supply persistence of the attributes to ensure they get passed between Java process boundaries.
 * Primary scenario for this class is to get MPS started in a distinct setup (e.g. by configuring IdeaEnvionment with EnvironmentConfig which gets populated with the properties serialized by this class)
 * Unlike Script counterpart, doesn't know anything about specific ant tasks and their possible arguments.
 * 
 * Collections are returned by-reference and could be modified from outside (this class is just a data holder + persistence)
 * 
 * FIXME deserves better name
 * 
 * FIXME auxiliary properties are likely not part of MPS startup sequence
 * FIXME myLibraries - what the hell is 'name' key, and do I really want to stick to File there provided I may use macro values as part of a library path
 */
public class ScriptData {
  private static final String ROOT_TASKDATA = "taskdata";
  private static final String PROP_WORKER = "worker";
  private static final String PROP_FAILONERROR = "failOnError";
  private static final String PROP_LOGLEVEL = "logLevel";
  private static final String PROP_LOADBOOTSTRAPLIBRARIES = "loadBootstrapLibraries";
  private static final String ELEM_PROPERTY = "property";
  private static final String ELEM_MACRO = "macro";
  private static final String NAME = "name";
  private static final String VALUE = "value";
  private static final String PATH = "path";
  private static final String ID = "id";

  private static final String ELEM_LIBRARIES = "libraries";
  private static final String ELEM_LIBRARY = "library";
  private static final String ELEM_LIBRARYJAR = "jar";

  private static final String ELEM_REPO = "repository";
  private static final String ELEM_REPO_FOLDER = "folder";
  private static final String ELEM_REPO_MODULEFILE = "module";
  private static final String ELEM_PLUGIN = "plugin";

  private String myWorker;
  private boolean myFailOnError = true;
  private Level myLogLevel = Level.INFO;
  private boolean myLoadBootstrapLibraries = true;
  private Map<String, String> myProperties = new LinkedHashMap<String, String>();
  private Map<String, String> myMacros = new LinkedHashMap<String, String>();
  private Map<String, File> myLibraries = new LinkedHashMap<String, File>();
  private final List<String> myLibraryJars = new ArrayList<String>();
  private final List<PluginData> myPlugins = new ArrayList<PluginData>();

  private RepositoryDescriptor myRepo = null;

  public ScriptData() {
  }

  public void write(Element root) {
    Element misc = new Element(ROOT_TASKDATA);
    if (myWorker != null) {
      misc.setAttribute(PROP_WORKER, myWorker);
    }
    misc.setAttribute(PROP_FAILONERROR, Boolean.toString(myFailOnError));
    misc.setAttribute(PROP_LOGLEVEL, Integer.toString(myLogLevel.toInt()));
    misc.setAttribute(PROP_LOADBOOTSTRAPLIBRARIES, Boolean.toString(myLoadBootstrapLibraries));
    root.addContent(misc);

    if (!(myLibraries.isEmpty()) || !(myLibraryJars.isEmpty())) {
      Element libraries = new Element(ELEM_LIBRARIES);
      for (String key : myLibraries.keySet()) {
        libraries.addContent(new Element(ELEM_LIBRARY).setAttribute(NAME, key).setAttribute(PATH, myLibraries.get(key).getAbsolutePath()));
      }
      for (String jar : myLibraryJars) {
        libraries.addContent(new Element(ELEM_LIBRARYJAR).setAttribute(PATH, jar));
      }
      root.addContent(libraries);
    }

    if (myRepo != null) {
      Element repo = new Element(ELEM_REPO);
      for (String f : myRepo.folders) {
        repo.addContent(new Element(ELEM_REPO_FOLDER).setAttribute(PATH, f));
      }
      for (String f : myRepo.files) {
        repo.addContent(new Element(ELEM_REPO_MODULEFILE).setAttribute(PATH, f));
      }
      root.addContent(repo);
    }
    for (String key : myMacros.keySet()) {
      root.addContent(new Element(ELEM_MACRO).setAttribute(NAME, key).setAttribute(VALUE, myMacros.get(key)));
    }
    for (PluginData p : myPlugins) {
      root.addContent(new Element(ELEM_PLUGIN).setAttribute(PATH, p.path).setAttribute(ID, (p.id == null ? "" : p.id)));
    }
    // auxiliary properties one may want to share using this script. They are not interpreted by MPS startup sequence 
    // and therefore shall not be part of the class, perhaps. OTOH, it's quite convenient to keep everything related to values passed between task and worker in a single place. 
    for (String key : myProperties.keySet()) {
      root.addContent(new Element(ELEM_PROPERTY).setAttribute(NAME, key).setAttribute(VALUE, myProperties.get(key)));
    }
  }

  public void read(Element root) {
    Element misc = root.getChild(ROOT_TASKDATA);
    myWorker = misc.getAttributeValue(PROP_WORKER);
    myFailOnError = Boolean.parseBoolean(misc.getAttributeValue(PROP_FAILONERROR));
    int logLevelInt = Integer.parseInt(misc.getAttributeValue(PROP_LOGLEVEL));
    myLogLevel = Level.toLevel(logLevelInt, Level.INFO);
    myLoadBootstrapLibraries = Boolean.parseBoolean(misc.getAttributeValue(PROP_LOADBOOTSTRAPLIBRARIES));

    for (Element e : root.getChildren(ELEM_LIBRARIES)) {
      for (Element lib : e.getChildren(ELEM_LIBRARY)) {
        File file = new File(lib.getAttributeValue(PATH));
        addLibrary(lib.getAttributeValue(NAME), file);
      }
      for (Element lib : e.getChildren(ELEM_LIBRARYJAR)) {
        addLibraryJar(lib.getAttributeValue(PATH));
      }
    }

    for (Element e : root.getChildren(ELEM_REPO)) {
      RepositoryDescriptor repo = new RepositoryDescriptor();
      for (Element f : e.getChildren(ELEM_REPO_FOLDER)) {
        repo.folders.add(f.getAttributeValue(PATH));
      }
      for (Element f : e.getChildren(ELEM_REPO_MODULEFILE)) {
        repo.files.add(f.getAttributeValue(PATH));
      }
      // I know I'm inside a loop, but I don't expect more that 1 <repo> tag 
      setRepo(repo);
    }

    for (Element e : root.getChildren(ELEM_MACRO)) {
      addMacro(e.getAttributeValue(NAME), e.getAttributeValue(VALUE));
    }
    for (Element e : root.getChildren(ELEM_PLUGIN)) {
      addPlugin(new PluginData(e.getAttributeValue(PATH), e.getAttributeValue(ID)));
    }
    for (Element e : root.getChildren(ELEM_PROPERTY)) {
      addProperty(e.getAttributeValue(NAME), e.getAttributeValue(VALUE));
    }
  }

  public void setWorker(String workerClass) {
    myWorker = workerClass;
  }
  public String getWorker() {
    return myWorker;
  }
  public void setFailOnError(boolean failOnError) {
    myFailOnError = failOnError;
  }
  public boolean getFailOnError() {
    return myFailOnError;
  }
  public void setLogLevel(Level logLevel) {
    myLogLevel = logLevel;
  }
  public Level getLogLevel() {
    return myLogLevel;
  }
  public RepositoryDescriptor getRepo() {
    return myRepo;
  }
  public void setRepo(RepositoryDescriptor repo) {
    myRepo = repo;
  }
  public void setLoadBootstrapLibraries(boolean isLoadBootstrapLibraries) {
    myLoadBootstrapLibraries = isLoadBootstrapLibraries;
  }
  public boolean getLoadBootstrapLibraries() {
    return myLoadBootstrapLibraries;
  }
  public void setProperties(Map<String, String> properties) {
    myProperties = properties;
  }
  public Map<String, String> getProperties() {
    return myProperties;
  }
  public void addProperty(String key, String value) {
    myProperties.put(key, value);
  }
  public void setMacros(Map<String, String> macros) {
    myMacros = macros;
  }
  public Map<String, String> getMacros() {
    return myMacros;
  }
  public void addMacro(String key, String value) {
    myMacros.put(key, value);
  }
  public List<PluginData> getPlugins() {
    return myPlugins;
  }
  public void addPlugin(PluginData p) {
    myPlugins.add(p);
  }
  public void setLibraries(Map<String, File> libraries) {
    myLibraries = libraries;
  }
  public Map<String, File> getLibraries() {
    return myLibraries;
  }
  /**
   * XXX seems to be identical to library jar, both end up in EnvironmentConfig.addLib(). Deprecate?
   * 
   * @param name unused
   * @param library library location
   */
  public void addLibrary(String name, File library) {
    myLibraries.put(name, library);
  }

  public void addLibraryJar(String libraryJar) {
    myLibraryJars.add(libraryJar);
  }
  public List<String> getLibraryJars() {
    return myLibraryJars;
  }
}
