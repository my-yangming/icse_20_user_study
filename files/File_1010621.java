package jetbrains.mps.tool.builder;

/*Generated by MPS */

import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.compiler.JavaCompilerOptions;
import jetbrains.mps.tool.environment.Environment;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.tool.common.JavaCompilerProperties;
import jetbrains.mps.compiler.JavaCompilerOptionsComponent;
import jetbrains.mps.tool.environment.EnvironmentConfig;
import jetbrains.mps.tool.common.RepositoryDescriptor;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.tool.common.PluginData;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.log4j.Logger;
import jetbrains.mps.project.Project;
import jetbrains.mps.components.ComponentHost;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collection;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.LinkedHashSet;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.io.DescriptorIOFacade;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.library.ModulesMiner;
import org.apache.log4j.Level;
import java.io.StringWriter;
import java.io.PrintWriter;

/**
 * MPS-aware job triggered by an Ant task. Unlike the task, assumes MPS classes in the classpath. 
 * Extent of the classes is not well defined, though and may vary from worker to worker (e.g. some gonna use IdeaEnironment and hence 
 * need IDEA platform, others may stick to MpsEnvironment with less classes in the classpath). The mechanism to describe this is not 
 * well-defined at the moment. Now MPS workers start with a help of a code in MpsLoadTask class which generally loads everything 
 * under mps-home/lib based on Ant Project properties (various "artifacts.*" values). Task has control over classpath through 
 * MpsLoadTask#calculateClassPath() method and may supply extra elements in use by particular worker (e.g. MigrationTask adds jars of migration plugin)
 */
public abstract class WorkerBase {
  protected final List<String> myErrors = new ArrayList<String>();
  protected final Script myWhatToDo;
  protected final JavaCompilerOptions myJavaCompilerOptions;
  protected final boolean mySkipCompilation;
  protected Environment myEnvironment;
  private final BaseMPSModuleOwner myOwner = new BaseMPSModuleOwner();

  public WorkerBase(Script whatToDo) {
    myWhatToDo = whatToDo;
    JavaCompilerProperties javaProperties = new JavaCompilerProperties(myWhatToDo);
    myJavaCompilerOptions = getJavaCompilerOptions(javaProperties);
    mySkipCompilation = javaProperties.isSkipCompilation();
  }

  private static JavaCompilerOptions getJavaCompilerOptions(JavaCompilerProperties javaProperties) {
    JavaCompilerOptionsComponent.JavaVersion parsedJavaVersion = JavaCompilerOptionsComponent.JavaVersion.parse(javaProperties.getTargetJavaVersion());
    if (parsedJavaVersion == null) {
      return JavaCompilerOptionsComponent.DEFAULT_JAVA_COMPILER_OPTIONS;
    }

    return new JavaCompilerOptions(parsedJavaVersion);
  }

  protected abstract Environment createEnvironment();

  protected EnvironmentConfig createEnvironmentConfig(Script whatToDo) {
    EnvironmentConfig config = EnvironmentConfig.emptyConfig().withDefaultSamples().withDefaultPlugins();
    RepositoryDescriptor repo = whatToDo.getRepoDescriptor();
    if (repo != null) {
      config = config.withBootstrapLibraries().withWorkbenchPath();
      // todo make this code more typed 
      for (String folder : repo.folders) {
        if (!(new File(folder).exists())) {
          warning("Modules folder does not exist: " + folder);
        }
        config = config.addLib(folder);
      }
      for (String file : repo.files) {
        if (!(new File(file).exists())) {
          warning("Module file does not exist: " + file);
        }
        config = config.addLib(file);
      }
    } else {
      config = config.withBootstrapLibraries().withWorkbenchPath();
    }
    for (IMapping<String, String> macro : MapSequence.fromMap(whatToDo.getMacro())) {
      config.addMacro(macro.key(), new File(macro.value()));
    }
    for (IMapping<String, File> lib : MapSequence.fromMap(whatToDo.getLibraries())) {
      config.addLib(lib.value().getAbsolutePath());
    }
    for (String jar : whatToDo.getLibraryJars()) {
      File jarFile = new File(jar);
      if (!(jarFile.exists())) {
        warning("Library " + jar + " does not exist.");
      }
      config.addLib(jar);
    }
    // let Environment know which idea plugins are expected to be loaded. 
    // Note, this doesn't address plugin classpath, as it's up to respective Task to decide whether respective plugins and their classes/libraries 
    // are in a global classpath or plugin classes are loaded in any other way. 
    for (PluginData pd : ListSequence.fromList(whatToDo.getPlugins())) {
      config.addPlugin(pd.path, pd.id);
    }
    return config;
  }

  public void workFromMain() {
    try {
      Logger.getRootLogger().setLevel(myWhatToDo.getLogLevel());
      myEnvironment = createEnvironment();
      work();
      dispose();
      System.exit(0);
    } catch (Throwable e) {
      log(e);
      System.exit(1);
    }
  }

  public abstract void work();

  protected Project createDummyProject() {
    return myEnvironment.createEmptyProject();
  }

  protected void dispose() {
    if (myEnvironment != null) {
      myEnvironment.dispose();
      myEnvironment = null;
    }
  }

  protected final ComponentHost getPlatform() {
    return myEnvironment.getPlatform();
  }

  protected StringBuffer formatErrorsReport(String taskName) {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < 100; i++) {
      sb.append('*');
    }
    sb.append("\n");
    sb.append(myErrors.size());
    sb.append(" errors during " + taskName + ":\n");
    for (String error : myErrors) {
      sb.append(error);
      sb.append("\n");
    }
    for (int i = 0; i < 100; i++) {
      sb.append('*');
    }
    return sb;
  }
  protected void failBuild(String name) {
    if (!(myErrors.isEmpty()) && myWhatToDo.getFailOnError()) {
      throw new RuntimeException(this.formatErrorsReport(name).toString());
    }
  }

  protected void extractModels(Set<SModel> result, Project project) {
    for (SModule module : project.getProjectModulesWithGenerators()) {
      for (SModel model : module.getModels()) {
        if (includeModel(model)) {
          result.add(model);
        }
      }
    }
  }
  private boolean includeModel(SModel model) {
    return !(SModelStereotype.isStubModel(model)) && GenerationFacade.canGenerate(model);
  }
  protected void extractModels(Collection<SModel> modelsList, SModule m) {
    for (SModel d : m.getModels()) {
      if (includeModel(d)) {
        modelsList.add(d);
      }
    }
  }
  /**
   * XXX Perhaps, would be better to pass Project here so that we populate Project explicitly, rather
   * than collect some modules (under Project's MA lock!), but process them independently using ObjectsToProcess
   */
  protected Set<SModule> collectFromModuleFiles(SRepository repo) {
    // XXX don't want to have ordering here but used to be that way in GenTestWorker and might be helpful 
    // to reproduce errors/get predictable behavior. 
    Set<SModule> modules = new LinkedHashSet<SModule>();
    // FIXME GenTestWorker/GenTestTask still use module files as configuration argument (from Java code perspective, need to check actual tasks in scripts and generator thereof) 
    for (File moduleFile : myWhatToDo.getModules()) {
      processModuleFile(repo, moduleFile, modules);
    }
    return modules;
  }
  /**
   * Discovers module(s) from specified location of a module descriptor, loads and registers them in
   * global (JUST FOR NOW) repository with custom owner.
   * 
   * The method used to filter out read-only module and DevKit which is odd provided we have no idea what's the reason to load the module in the first place.
   * Now it's caller responsibility to deal with loaded modules and ignore those undesired as appropriate.
   * 
   * @param moduleSourceDescriptorFile not null
   * @param modules collection to populate, not null.
   */
  protected void processModuleFile(SRepository repo, final File moduleSourceDescriptorFile, final Set<SModule> modules) {
    // XXX need a way to figure which FS to use here. Techically, it should come from a project as we are going to 
    // use these modules as part of the project. 
    final FileSystem fs = FileSystem.getInstance();
    IFile descriptorFile = fs.getFile(moduleSourceDescriptorFile.getPath());
    DescriptorIOFacade descriptorIOFacade = myEnvironment.getPlatform().findComponent(DescriptorIOFacade.class);
    if (descriptorIOFacade.fromFileType(descriptorFile) == null) {
      info(String.format("File %s doesn't point to module descriptor, ignored", moduleSourceDescriptorFile));
      return;
    }
    ModuleRepositoryFacade mrf = new ModuleRepositoryFacade(repo);
    for (ModulesMiner.ModuleHandle moduleHandle : new ModulesMiner(myEnvironment.getPlatform()).collectModules(descriptorFile).getCollectedModules()) {
      //  seems reasonable just to instantiate a module here and leave its registration to caller 
      SModule module = mrf.instantiateModule(moduleHandle, myOwner);
      info("Loaded module " + module);
      modules.add(module);
    }
  }

  private void log(String text, Level level) {
    if (!(level.isGreaterOrEqual(myWhatToDo.getLogLevel()))) {
      return;
    }

    if (level == Level.ERROR) {
      System.err.println(text);
    } else {
      System.out.println(text);
    }
  }
  public void info(String text) {
    log(text, Level.INFO);
  }
  public void warning(String text) {
    log(text, Level.WARN);
  }
  public void debug(String text) {
    log(text, Level.DEBUG);
  }
  public void error(String text) {
    log(text, Level.ERROR);
    myErrors.add(text);
  }
  public void log(Throwable e) {
    StringBuffer sb = WorkerBase.extractStackTrace(e);
    error(sb.toString());
  }
  public void log(String text, Throwable e) {
    StringBuffer sb = WorkerBase.extractStackTrace(e);
    error(text + "\n" + sb.toString());
  }
  public static StringBuffer extractStackTrace(Throwable e) {
    StringWriter writer = new StringWriter();
    e.printStackTrace(new PrintWriter(writer));
    return writer.getBuffer();
  }
}
